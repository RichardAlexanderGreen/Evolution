Object subclass: #DailyStatMatrix	instanceVariableNames: 'matrix'	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!DailyStatMatrix commentStamp: 'RichardAlexanderGreen 1/15/2013 09:33' prior: 0!DailyStatMatrix Rows are associated with tickers.Columns are associated with days.Cell values are numbers.Expect to see matrices like this:1.  x = price at close.2. sumX = cumulative sum of X from first day to current column day.3. sumX2 = sum of X*X (x squared)4. n = sum of one.From these values we can calculate moving averages with their respective standard deviations.!!DailyStatMatrix methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/18/2013 11:18'!forTicker: aTicker date: aDate 	| row column value |	self assert: ( aTicker isKindOf: String  ).	self assert: ( aDate isKindOf: Date ).		row := DailyStatMatrix rowForTicker: aTicker.	column := DailyStatMatrix columnForDay: aDate.		value := ( self matrix ) at: row at: column.	"self assert: ( value isKindOf: Number  )."	^value.! !!DailyStatMatrix methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 14:09'!insert: value forTicker: aTicker date: aDate 	"Insert the given number at the matrix row for ticker and column for aDate "	| row column |	self assert: ( value isKindOf: Number  ).	self assert: ( aTicker isKindOf: String  ).	self assert: ( aDate isKindOf: Date ).		row := DailyStatMatrix rowForTicker: aTicker.	column := DailyStatMatrix columnForDay: aDate.		( self matrix ) at: row at: column put: value.! !!DailyStatMatrix methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 10:20'!insert: value forTicker: aTicker day: yyyymmdd 	"Insert the given number at the matrix row for ticker and column for yyyymmdd "	| row column |	self assert: ( value isKindOf: Number  ).	self assert: ( aTicker isKindOf: String  ).	self assert: ( yyyymmdd isKindOf: String ).		row := DailyStatMatrix rowForTicker: aTicker.	column := DailyStatMatrix columnForDay: yyyymmdd.		matrix at: row at: column put: value.! !!DailyStatMatrix methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 16:11'!matrix	"Return my internal matrix.	TODO: Consider subclassing Matrix.	TODO: Consider a more efficient use of memory."	^ matrix ifNil: [ matrix := Matrix rows: 3000 columns: ((DailyStatMatrix days) size) ].! !!DailyStatMatrix methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 1/16/2013 14:23'!forEachDayInHistoryOf: aTicker from: dateStart until: dateStop do: aBlockClosure 	"provide the cell values to the block"	| row columnStart columnStop |	row := DailyStatMatrix rowForTicker: aTicker.	columnStart := DailyStatMatrix columnForDay: dateStart.	columnStop := DailyStatMatrix columnForDay: dateStop.		( columnStart to: columnStop )		do: [ :column |			| cell |			cell := matrix at: row at: column.			aBlockClosure value: cell.			].	  	! !!DailyStatMatrix methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 2/9/2013 10:42'!forEachRowAndColumnFrom: dateStart until: dateStop do: aBlockClosure 	"Run the block closure for all rows and all columns in the date range."	| columnStart columnStop rowStop |	columnStart := DailyStatMatrix columnForDay: dateStart.  		columnStop := DailyStatMatrix columnForDay: dateStop.  	rowStop := DailyStatMatrix rowHeads size.	( self matrix )		withIndicesDo: [ :value :row :column | 			((( column >= columnStart ) and: [ column <= columnStop ]) and: [row < rowStop])				ifTrue: [ aBlockClosure value: row value: column value: value ].				 ].! !!DailyStatMatrix methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 1/16/2013 15:49'!forEachTickerAndDayFrom: dateStart until: dateStop do: aBlockClosure 	"provide the cell values to the block"	| row columnStart columnStop |		( DailyStatMatrix tickers )		keysDo:  [ :ticker	|			row := DailyStatMatrix rowForTicker: ticker.			columnStart := DailyStatMatrix columnForDay: dateStart.			columnStop := DailyStatMatrix columnForDay: dateStop.			( columnStart to: columnStop )				do: [ :column |					| cell |					cell := matrix at: row at: column.					aBlockClosure value: ticker value: cell.					].			].	  ! !!DailyStatMatrix methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 2/8/2013 16:20'!forEachTickerDo: aBlockClosure 	"Do the block for each ticker."	(DailyStatMatrix tickers)		do: [ :ticker | aBlockClosure value: ticker ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DailyStatMatrix class	instanceVariableNames: 'matrices nRows nColumns tickers days dates firstDate lastDate log rowHeads columnHeads'!!DailyStatMatrix class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/16/2013 15:31'!loadDataFromStream: aReadStream 	 "Load data from the given read stream"	| columns matrix filtered |	columns := #( #ticker #day #open #high #low #close #volume ).	matrix := DailyStatMatrix called: #close.	filtered := 0.	.[ aReadStream atEnd ]		whileFalse: [ "For each line:"			| dataLine  fields ticker yyyymmdd volume value tokens ignore |			dataLine := aReadStream nextLine.	            fields := self parseLine: dataLine intoDailyStatFields: columns.			value := (fields at: #close) asNumber.			ticker := fields at: #ticker.			yyyymmdd := fields at: #day.			volume := fields at: #volume.			"FILTER"			"If the ticker contains a special character, ignore it.			These 'extensions'' indicate special cases that tend to cause problems."			tokens :=  ticker subStrings: '/.-'. 			ignore := ( tokens size > 1 ) or: [ value = 0.0 or: [ volume = 0 ] ]. 			ignore  				ifTrue: [ filtered := filtered +1 ]				ifFalse: [ matrix insert: value forTicker: ticker day: yyyymmdd. ]   					].	Transcript show: ' filtered: ', ( filtered asString ).! !!DailyStatMatrix class methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/15/2013 16:14'!loadDataFromZipArchiveNamed: aFileName	"Read a zip in the investment source files directory"	| file archive |	file := StandardFileStream readOnlyFileNamed: aFileName.	self assert: ( file size > 0 ).	self assert: ( ZipArchive isZipArchive: file ).		archive := ZipArchive new.	archive readFrom: file.	self assert: ( archive members size > 0 ).		archive members		do: [ :member |			| bigString tempStream firstLine |			Transcript cr; show: 'Loading data from: ', (member fileName).			bigString := member contents.			tempStream := ReadStream on: bigString.			firstLine := tempStream nextLine.			self assert: ( firstLine = '<ticker>,<date>,<open>,<high>,<low>,<close>,<vol>' ).			DailyStatMatrix loadDataFromStream: tempStream.			self assert: ( tempStream atEnd ).			].! !!DailyStatMatrix class methodsFor: 'converting' stamp: 'RichardAlexanderGreen 1/15/2013 11:31'!dateFromYYYYMMDD: aString 	"Create a Date from string in the form YYYYMMDD"	| yyyy mm dd date |	yyyy := aString copyFrom: 1 to: 4.	mm := aString copyFrom: 5 to: 6.	dd := aString copyFrom: 7 to: 8.	date := Date year: (yyyy asInteger ) month: (mm asInteger ) day: (dd asInteger ).	^date.! !!DailyStatMatrix class methodsFor: 'converting' stamp: 'RichardAlexanderGreen 1/15/2013 10:00'!parseLine: aString intoDailyStatFields: anArray	"Parse the given line into fields whose names are given by anArray of symbols"	| fields tokens i |	fields := Dictionary new.	tokens := aString findTokens: ',' keep: '' . 	i := 0.	anArray do: [ :symbol | 		| columnName fieldValue |		i := i + 1.		columnName := anArray at: i.		fieldValue := tokens at: i.		fields at: columnName put: fieldValue.		].	^fields.! !!DailyStatMatrix class methodsFor: 'associating' stamp: 'RichardAlexanderGreen 1/15/2013 10:04'!called: aSymbol 	"Return the matrix associated with this symbol."	| matrix |	matrix := ( self matrices ) at: aSymbol ifAbsent: [ nil ].	matrix 		ifNil: [ matrix := self createMatrix. 			 ( self matrices ) at: aSymbol put: matrix.			].	^matrix.! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/8/2013 18:48'!clearDatabase	matrices := nil.	days := nil.	dates := nil.	tickers := nil.	"Following may be adjusted to adapt or optimize"	nRows := 0.	nColumns := 0.	firstDate := nil.	lastDate := nil.	" 2500 * 2620 = 6550000 "	firstDate ifNil: [ firstDate := Date year: 2007 month: 01 day: 01 ].		lastDate ifNil: [ lastDate := Date year: 2009 month: 12 day: 31 ].	self days.	self assert: ( days isEmpty not ).	self assert: ( dates isEmpty not ).		self assert: ( dates size ) = ( days size ).		self assert: ( days size ) < ( ( lastDate - firstDate ) days ).! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 11:37'!columnForDay: yyyymmdd	"Return the column index associated with the given date"	| column |	( yyyymmdd isKindOf: Date )		ifTrue: [ ^column := (self dates) at: yyyymmdd 								ifAbsent: [Error signal: 'Trouble with date lookup'] ].	"Otherwise"	( yyyymmdd isKindOf: String )		ifTrue: [ ^column := (self days) at: yyyymmdd 									ifAbsent: [ Error signal: 'Trouble with yyyymmdd lookup'] ] 		ifFalse: [ Error signal: 'yyyymmdd is wrong type'].	"Should not get this far."	column ifNil: [ Error signal: 'Trouble with column lookup'  ].	^column		! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2013 10:23'!columnHeads	"This is the reverse dictionary for column indices."	^ columnHeads ifNil: [ columnHeads := Dictionary new ].! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 11:35'!dates	^ dates ifNil: [ Error signal: 'Date lookup is not initialized.' ].! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2013 10:22'!days	|  n column day isWeekDay |	self assert: ( self columnHeads notNil ).	days 		ifNil: [ "Create and populate the days dictionary"			days := Dictionary new.			dates := Dictionary new.			isWeekDay := [ :date | (( date weekday asString ) beginsWith: 'S' ) not ].			n := 0.			column := 0.			day := ( firstDate addDays: n  ).			[ day <= lastDate ]				whileTrue: [					"Is it a weekday?  (Ignore otherwise)"					( isWeekDay value: day )						ifTrue: [ "Put column index into look-up dictionaries"							| yyyymmdd |							column := column + 1. "next column"							dates at: day put: column.							yyyymmdd := ( day yyyymmdd ) select: [ :each | each isDigit ].							days at: yyyymmdd put: column.							columnHeads at: column put: day.							].					n := n + 1.  "next day"					day := ( firstDate addDays: n ).					]. " < lastDate"			Transcript cr; show: 'DailyStatMatrix columns = ', column asString, '  ( weekdays ) in period of ', n asString, ' days'.			]. "ifNil"	self assert: ( days notNil ).	self assert: ( days notEmpty ).	self assert: ( dates notNil ).	self assert: ( dates notEmpty ).	^ days		! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 10:05'!matrices	 ^matrices ifNil: [ matrices := Dictionary new ].! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/18/2013 12:05'!nextBusinessDayAfter: aDate 	"Find the next day aftoer the given day where we have data."	| nextBusinessDay |		self assert: ( aDate >= firstDate ).	nextBusinessDay := aDate addDays: 1.	[ (dates at: nextBusinessDay ifAbsent: [nil ]) isNil ]		whileTrue: [			nextBusinessDay := nextBusinessDay addDays: 1.			self assert: ( nextBusinessDay <= lastDate ).			 ].	^ nextBusinessDay.  ! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2013 09:47'!rowForTicker: aTicker	"Get the row index for this ticker string"	| row |	self assert: (aTicker isKindOf: String  ).	row := ( self tickers ) at: aTicker ifAbsent: [ nil ].	row ifNil: [ nRows := nRows + 1.				row := nRows.				( self tickers ) at: aTicker put: row.				( self rowHeads ) at: row put: aTicker.				].	( row = 0 )		ifTrue: [ "Ticker has been removed due to flakey data."			^nil.			].	^row.! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/9/2013 09:52'!rowHeads	^ rowHeads ifNil: [ rowHeads := Dictionary new. ].! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2013 22:47'!sampleTickersOfSize: nTickers	"select a set of tickers at random"	|  sample n rate random |	sample := Set new.	n := tickers size.	rate := nTickers / ( n + 0.0 ).	self assert: ( rate < 1.0 ).	random := Random new.	random initialize.	"Note: database is a Dictionary "	[ sample size < nTickers ]  		whileTrue:  [				tickers keysDo: [ :ticker |				| chance |				chance := random next.				( chance <= rate) ifTrue: [ sample add: ticker ].				( (sample size) >= nTickers ) ifTrue: [ ^ sample ].				].  			].	Error signal: 'How did we get here?'.	^sample.! !!DailyStatMatrix class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/15/2013 10:29'!tickers	^tickers ifNil: [ tickers := Dictionary new. ].! !!DailyStatMatrix class methodsFor: 'instance creation' stamp: 'RichardAlexanderGreen 2/8/2013 19:03'!createMatrix	| instance |	instance := self basicNew.	instance matrix.	^instance.! !!DailyStatMatrix class methodsFor: 'enumerating' stamp: 'RichardAlexanderGreen 1/16/2013 12:39'!forEachTickerDo: aBlockClosure 	"Do the block for each ticker."	(self tickers)		do: [ :ticker | aBlockClosure value: ticker ].! !!DailyStatMatrix class methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 1/28/2013 07:33'!listRemovedTickers	"List the tickers that have been removed."	| count |	count := 0.0.	Transcript cr; show: 'The following tickers were removed: '.	tickers		keysAndValuesDo:    [ :ticker :row |			( row = 0 )				ifTrue: [					count := count + 1.					Transcript show: (' ',  ticker).					]									].	Transcript cr; show: ( count asString ), ' tickers were removed.'.	Transcript cr.! !!DailyStatMatrix class methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 1/28/2013 07:11'!log	^ log ifNil: [ log := OrderedCollection new ].! !!DailyStatMatrix class methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 1/28/2013 07:11'!log: aString	"Record the sting in my log collection for later analysis."	( self log ) add: aString.! !!DailyStatMatrix class methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 2/13/2013 17:37'!removeTicker: aTicker	"Debug data -- Remove that ticker from the database -- It is causing too much problem."	tickers at: aTicker put: 0.! !!DailyStatMatrix class methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 2/13/2013 17:37'!removeTicker: aTicker faultDate: aDate because: aString	"Debug data -- Remove that ticker from the database -- It is causing too much problem.	Record the reason and the associated date in the log.	"	| logString |	self removeTicker: aTicker.	"Log the reason"	logString := (  String cr, 'Removed ticker: ', aTicker, ' near date: ', aDate asString, ' because: ', aString  ). 	self log: logString.		true ifTrue: [ Transcript cr; show: logString ].! !TestCase subclass: #StockHoldingTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/14/2013 10:06'!test110StockHoldingAttributes	"A holding attributes include id, ticker, quantity, whenBot, whenSold, priceBot, priceSold, fees, dividends, gain."	| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45;		whenSold: (Date year: 2012 month: 12 day: 31);		priceSold: 54.54;		fees: 14.00;		dividends: 3.67.	"The following might not be correct for income tax purposes."	self assert:  ( (100*(54.54-45.45)) - 14.00 + 3.67 )  equals: holding gain. 	self assert: ( 306 ) equals: holding daysHeld.! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/29/2012 12:52'!test120GainIsNilUntilStockIsSold	"A holding attributes include id, ticker, quantity, whenBot, whenSold, priceBot, priceSold, fees, dividends, gain."	| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45;		fees: 7.00;		dividends: 3.67.	"The following might not be correct for income tax purposes."	self assert:  ( holding gain isNil ).! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/29/2012 12:54'!test130AddFee	"We need to add fees as they are billed."	| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		"A holding attributes include id, ticker, quantity, whenBot, whenSold, priceBot, priceSold, fees, dividends, gain."	holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45;		fees: 7.00;		dividends: 3.67.		holding addFee: 8.88.	self assert: ( holding fees = 15.88 ).! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/3/2013 23:43'!test140AddDividend	"We need to add dividends as they are realized."	| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		"A holding attributes include id, ticker, quantity, whenBot, whenSold, priceBot, priceSold, fees, dividends, gain."	holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45;		fees: 7.00;		dividends: 0.0.		holding addDividend: 3.64 / 4.	self assert: ( holding dividends = ( ( 3.64 / 4 ) * 100 ) ).! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/29/2012 13:01'!test150FeesAndDividendsInitializedToZero	"Fees and dividends should be initialized to zero."	| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		"A holding attributes include id, ticker, quantity, whenBot, whenSold, priceBot, priceSold, fees, dividends, gain."	holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45.				self assert: 0.0 equals: holding fees.	self assert: 0.0 equals: holding dividends.	! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/7/2013 11:22'!test205AddPurchaseToPortfolio	"To keep things simple, we only ever have a single holding of a given ticker."	| holding |	StockHolding purchased: 'TEST' quantity: 100 on: ( Date year: 2012 month: 01 day: 31 ) for: 12.34.	"We can look to see if we already own a stock"	holding := StockHolding forTicker: 'TEST'.	self assert: ( holding isKindOf: StockHolding ).	! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/7/2013 11:22'!test210AddPurchaseToPortfolio	"Add a purchase to the stock holdings portfolio"	StockHolding purchased: 'TEST' quantity: 100 on: ( Date year: 2012 month: 01 day: 31 ) for: 12.34.! !!StockHoldingTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/14/2013 10:15'!test310Report	"Report the holding in a readable format -- prefer one line that keeps columns aligned."		| holding |	holding := StockHolding new.	self assert: ( holding id notNil ).		holding 		ticker: 'TEST';		quantity: 100;		whenBot: (Date year: 2012 month: 02 day: 29);		priceBot: 45.45;		whenSold: (Date year: 2012 month: 12 day: 31);		priceSold: 54.54;		fees: 14.00;		dividends: 3.67.	self assert: ( (holding report ) isKindOf: String  ).	Transcript cr; show: (holding report).	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StockHoldingTests class	instanceVariableNames: ''!Object subclass: #Strategy	instanceVariableNames: 'lag weightPositive weightNegative percentCapital percentLoss percentGain minimums maximums fitness numberOfLives fitnessHistory myRandomizer dayOfWeek'	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!Strategy commentStamp: 'RichardAlexanderGreen 12/29/2012 14:16' prior: 0!" A strategy decides when to buy/hold and when to sell a stock holding.The decision is based on pro and con weights.A score is calculated for each DailyStat based on weights and attributes of the stock history.The strongest strategy wins if it`s overall score is  above some threshold."!!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 12/31/2012 11:22'!dummyScoreFor: aHistory	"Compute a score for the given DailyStat history.	The history is a Dictionary holding ( Date -> DailyStat ) entries.	"	| score |	self assert: ( aHistory isKindOf: Dictionary ).	"Compute a score."	weightNegative ifNil: [ self randomize ].	score := 0.0.	"Return the given score."	^score.! !!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/2/2013 16:47'!pickBest: numberOfCandidates inSample: sampleTickers from: startDate until: endDate	"Pick the best (5 or so) buy / hold candidates from sample."	| candidates acceptanceScore tickerScore lowScore resetLowScoreFunction |	self assert: ( sampleTickers isKindOf: Set ).	self assert: ( numberOfCandidates isKindOf: Integer ).	candidates := Set new.	acceptanceScore := 0.0.	tickerScore := 0.0.	lowScore := 0.0.	resetLowScoreFunction := [ 	lowScore := tickerScore.								candidates do: [ :map | ( (map value) < lowScore )  ifTrue: [ lowScore := (map value) ]. ].   										].	sampleTickers		do: [ :ticker |			tickerScore := self scoreForTicker: ticker from: startDate until: endDate. 			( tickerScore > acceptanceScore )				ifTrue: [ "Add to candidate set"					| newSet  |					candidates add: ( ticker -> tickerScore ).					( candidates size >  numberOfCandidates )						ifTrue: [ "Weed out the lowest scoring candidate and reset the acceptanceScore "							resetLowScoreFunction value.							newSet := candidates reject: [ :map | 								| score criterion |								"Reject items whose score equals low score."								score := map value.								criterion := ( score <= lowScore ).								]. "end reject"							candidates := newSet.							]. "end size > 5"						"Find the new lowest score and reset the acceptance value."						resetLowScoreFunction value.   						acceptanceScore := lowScore.					].  "end score > acceptance"			]. "end tickers do:"	^candidates.	! !!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/29/2013 22:29'!runForTickers: sampleTickers from: startDate until: endDate inPortfolio: aPortfolio	"Run this strategy againt the sample tickers for the given period.	This version buys and sells on all weekdays."	| myFirstDay thisDay markToMarket  |		"Check to see if we should run the vaiation that only operates on a certain day of the week."	( dayOfWeek isNil ) 		ifFalse: [ "Run the variant that only operates one day a week"			       ^self runForTickers: sampleTickers 			                             from: startDate 			  					until: endDate 								inPortfolio: aPortfolio 								dayOfWeek: dayOfWeek									].	myFirstDay :=  DailyStatMatrix nextBusinessDayAfter: (startDate addDays: lag).	thisDay := myFirstDay.	[ thisDay <= endDate ]		whileTrue: [ "For each day:"			"First sell anything we own that is below the stop-loss percentage"			aPortfolio sellLosersBelow: ( self percentLoss ) on: thisDay.			aPortfolio sellWinersAbove: ( self percentGain ) on: thisDay.			( aPortfolio cashOnHand  > 1000 )				ifTrue: [ "We have sufficient funds.."					| candidates  nextBusinessDay |					"Identify some buy candidates"					candidates := self pickBest: 3 inSample: sampleTickers from: startDate until: thisDay.					"If we do not already own, and have funds, buy something."					nextBusinessDay := DailyStatMatrix nextBusinessDayAfter: thisDay.					aPortfolio considerPurchasing: candidates onDate: nextBusinessDay.					"TODO: Finess the weekends."					].			thisDay := DailyStatMatrix nextBusinessDayAfter: thisDay.				].		markToMarket := aPortfolio markToMarketOnDate: endDate.	fitness := markToMarket / ( aPortfolio initialCapital  ).	self addFitness: fitness.  	aPortfolio log: ( self shortReport ), ' markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2  ).  	^fitness		! !!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/30/2013 13:39'!runForTickers: sampleTickers from: startDate until: endDate inPortfolio: aPortfolio dayOfWeek: dayCode	"Run this strategy againt the sample tickers for the given period.	In this variation, the strategy only  buys on a given day each week.	"	| myFirstDay thisDay markToMarket  |	self assert: ( startDate isKindOf: Date ).	self assert: ( dayCode isKindOf: Integer ).	myFirstDay :=  DailyStatMatrix nextBusinessDayAfter: (startDate addDays: lag).	thisDay := myFirstDay.	[ thisDay <= endDate ]		whileTrue: [ "For each day:"				 	"First sell anything we own that is below the stop-loss percentage"					aPortfolio sellLosersBelow: ( self percentLoss ) on: thisDay.					aPortfolio sellWinersAbove: ( self percentGain ) on: thisDay.					( (  thisDay dayOfWeek = dayCode ) and: [ aPortfolio cashOnHand  > 1000]  ) 						ifTrue: [ "We can buy on this day."							| candidates  nextBusinessDay |							"Identify some buy candidates"							candidates := self pickBest: 3 inSample: sampleTickers from: startDate until: thisDay.							"If we do not already own, and have funds, buy something."							nextBusinessDay := DailyStatMatrix nextBusinessDayAfter: thisDay.							aPortfolio considerPurchasing: candidates onDate: nextBusinessDay.							]. "end We can buy . . ."					thisDay := DailyStatMatrix nextBusinessDayAfter: thisDay.						].	"while true "	"Calculate fitness"					markToMarket := aPortfolio markToMarketOnDate: endDate.	fitness := markToMarket / ( aPortfolio initialCapital  ).	self addFitness: fitness.  	aPortfolio log: ( self shortReport ), ' markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2  ).  	^fitness		! !!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/2/2013 16:05'!scoreFor: aHistory	"Compute a score for the given DailyStat history.	The history is a Dictionary holding ( Date -> DailyStat ) entries.	"	| score stats n mean standardDeviation  price x buyWhenUpScore buyWhenDownScore |	self assert: ( aHistory isKindOf: Dictionary ).	"Compute a score."	weightNegative ifNil: [ self randomize ].	stats := DailyStat statsFor: aHistory.	n := stats at: 1.	mean := stats at: 2.	standardDeviation := stats at: 3.	price := stats at: 4.	"X measures normalized distance from mean in standard deviations"	x := ( price - mean ) / standardDeviation.	"buy when up -- preference to buy when price is above mean -- Theory is that  will continue to rise"	buyWhenUpScore := 0.	( x > 0 ) ifTrue: [ buyWhenUpScore := x * weightPositive ].	"buy when down -- preference to buy when price is below mean -- Theory is that price will revert to mean."	 buyWhenDownScore := 0.	( x < 0 ) ifTrue: [ buyWhenDownScore := ( x * weightNegative ) negated ].	"Either way, what is the buy signal?"	score := buyWhenDownScore + buyWhenUpScore. 	"Return the given score."	^ ( score floor ).	! !!Strategy methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/26/2013 11:11'!scoreForTicker: aTicker from: startDate until: endDate	"Compute a score for the given DailyStat history.	"	| score  n2 n1 n cumXstart cumXend sumX mean cumX2start cumX2end sumX2 standardDeviation  price x buyWhenUpScore buyWhenDownScore variance |	self assert: ( aTicker isKindOf: String ).	"Compute a score."	weightNegative ifNil: [ self randomize ].	price := ( DailyStatMatrix called: #close ) forTicker: aTicker date: endDate.	( price isNil ) ifTrue: [ ^0 ].		n1 := ( DailyStatMatrix called: #n ) forTicker: aTicker  date: startDate.	n1 ifNil: [ ^ 0 ].	n2 := ( DailyStatMatrix called: #n ) forTicker: aTicker  date: endDate.	n2 ifNil: [ ^0 ].  	n := n2 - n1.  	cumXstart := ( DailyStatMatrix called: #cumX ) forTicker: aTicker date: startDate.	cumXend := ( DailyStatMatrix called: #cumX ) forTicker: aTicker date: endDate.	sumX := cumXend - cumXstart.	mean := sumX / n.	cumX2start := ( DailyStatMatrix called: #cumX2 ) forTicker: aTicker date: startDate.	cumX2end := ( DailyStatMatrix called: #cumX2 ) forTicker: aTicker date: endDate.	sumX2 := cumX2end - cumX2start.	( n = 1 )		ifTrue: [ variance := mean * mean ]		ifFalse: [ variance  := ( ( ( n * sumX2 ) - ( sumX * sumX ) ) / ( n * ( n - 1 ) ) ) ].	"Occasionally round-off errors will cause the variance to be a small negative number.	So we need to test before taking the square root.	"	( variance > 0 )		ifTrue: [ standardDeviation := variance sqrt ] 		ifFalse: [ ^0.0 ].   	  	"X measures normalized distance from mean in standard deviations"	( ( price closeTo: mean ) )		ifTrue: [ ^0.0 ]		ifFalse: [ x := ( price - mean ) / standardDeviation. ].	"buy when up -- preference to buy when price is above mean -- Theory is that  will continue to rise"	buyWhenUpScore := 0.	( x > 0 ) ifTrue: [ buyWhenUpScore := x * weightPositive ].	"buy when down -- preference to buy when price is below mean -- Theory is that price will revert to mean."	 buyWhenDownScore := 0.	( x < 0 ) ifTrue: [ buyWhenDownScore := ( x * weightNegative ) negated ].	"Either way, what is the buy signal?"	score := buyWhenDownScore + buyWhenUpScore. 	"Return the given score."	^ ( score floor ).	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 09:56'!addFitness: aFitness 	(self fitnessHistory) add: aFitness.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 10:00'!averageFitness	| n sum average |	n := 0.	sum := 0.0.	 ( self fitnessHistory )		do: [ :observation |			n := n + 1.			sum := sum + observation.			].	average := sum / n.	^average.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/28/2013 08:05'!check	"Report current parameter values""Each degree of freedom has a minimum and maximum value"	|  degreesOfFreedom  |	degreesOfFreedom := self degreesOfFreedom.	self assert: ( degreesOfFreedom size > 5 ).	degreesOfFreedom 		do: [ :factor |			|  min max |			min := self getMinimumFor: factor.  			max := self getMaximumFor: factor.  			self assert: ( min < max ).			].	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/29/2013 22:29'!dayOfWeek	^ dayOfWeek! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/29/2013 21:56'!dayOfWeek: anInteger 	"Limits operations to a given day of the week.	Nil if operations are to be all business days."	dayOfWeek := anInteger.	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2012 18:27'!degreesOfFreedom"	Parameters that may be varied in competing strategies.	Lag:	- Compute collect a sample series with given lag.	. Compute X = ( P-M ) / S 	. . where P is current price, 	. . M is moving sample mean, 	. . S is moving sample std deviation..	. This gives the number of standard deviations the price is above or below the mean.	Weight for buy when X is above.zero. (Theory: Price will continue to rise for some time.)	Weight for buy when X is below zero. (Theory: Price will return to mean.)	Percent of capital to commit to a buy signal.	Stop loss percentage. (Sell if price descends below that level.)	Profit goal.  (Sell if price exceeds that level.)"	^ #( 		#lag                   "number of calendar days to include in the sample"		#weightPositive "weight for buying when X is above zero"		#weightNegative "weight for buying when X is below zero"		#percentCapital		#percentLoss  "Sell if price descends below this level"		#percentGain "Sell if price ascends above this level"		).! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/28/2013 07:58'!degreesOfFreedomReport	"Report current parameter values""Each degree of freedom has a minimum and maximum value"	|  degreesOfFreedom  |	Transcript cr; show: 'List of degreesOfFreedom min-max: '; cr.	degreesOfFreedom := self degreesOfFreedom.	self assert: ( degreesOfFreedom size > 5 ).	degreesOfFreedom 		do: [ :factor |			|  min max |			min := self getMinimumFor: factor.  			max := self getMaximumFor: factor.  			Transcript cr; show: (factor asString), ' [', min asString ,'-', max asString,']'			].	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 10:25'!fitness	^ fitness! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 09:57'!fitnessHistory	^ fitnessHistory ifNil: [ fitnessHistory := OrderedCollection new ].! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:45'!getMaximumFor: aSymbol	"Get the minimum and maximum allowed value for the given parameter.	See also: degreesOfFreedom, setMinMaxLimits.	"	|  result |	result := ( self maximums ) at: aSymbol.	^result.	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:45'!getMinimumFor: aSymbol	"Get the minimum and maximum allowed value for the given parameter.	See also: degreesOfFreedom, setMinMaxLimits.	"	|  result |	result := ( self minimums ) at: aSymbol.	^result.	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 08:28'!initialize	"initialize this instance"	"Set the minimum and maximum values that will be allows for parameters in the degrees of freedom.	See also: degreesOfFreedom.
	"	self setMinMaxLimits.	numberOfLives := 0.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:18'!lag	^lag.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2013 23:39'!lag: aNumber	"Number of calendar days to include in sample (going back from latest available day)"	| x |	x := aNumber rounded.	self assert: ( x >= ( self getMinimumFor: #lag  ) ).	self assert: ( x <= ( self getMaximumFor: #lag  ) ).	lag := x.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2012 18:44'!maximums 	^ maximums ifNil: [ maximums := Dictionary new. ]! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2012 18:43'!minimums 	^ minimums ifNil: [ minimums := Dictionary new. ]! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 08:32'!numberOfLives	^ numberOfLives ifNil: [ numberOfLives := 0 ].! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 08:33'!numberOfLives: aSmallInteger 	numberOfLives := aSmallInteger! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:42'!percentCapital 	^percentCapital.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 11:57'!percentCapital: percent	"maximum percent of total capital to commit to a buy signal "	self assert: ( percent isKindOf: Number ).	self assert: ( percent >= ( self getMinimumFor: #percentCapital ) ).	self assert: ( percent <= ( self getMaximumFor: #percentCapital ) ).	percentCapital := percent	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:43'!percentGain	^percentGain.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:04'!percentGain: percent	"Sell a holding if price ascends above this level."	self assert: ( percent isKindOf: Number ).	self assert: ( percent >= ( self getMinimumFor: #percentGain ) ).	self assert: ( percent <= ( self getMaximumFor: #percentGain ) ).	percentGain := percent	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:43'!percentLoss 	^percentLoss.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:02'!percentLoss: percent	"Sell a holding if price descends below this level."	self assert: ( percent isKindOf: Number ).	self assert: ( percent >= ( self getMinimumFor: #percentLoss ) ).	self assert: ( percent <= ( self getMaximumFor: #percentLoss ) ).	percentLoss := percent	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 12:34'!random	myRandomizer 		ifNil: [ myRandomizer := Random new.			myRandomizer initialize.			].	^myRandomizer.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 12:33'!randomize	"Set my parameters to randomized values."	| random parameters |	random := (self random).	parameters := self degreesOfFreedom.	parameters		do: [ :factor |			| min max value |			min := ( self minimums ) at: factor.			max := ( self maximums ) at: factor.			value := ( min +( ( random next ) * ( max - min ) ) )  asInteger.			self perform: ( factor asString, ':' ) asSymbol with: value.			].! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/18/2013 14:13'!report	"Report current parameter values"	|  attributes |	Transcript cr; show: 'Strategy values { '.	attributes := self degreesOfFreedom.	attributes		do: [ :attribute |			| value |			value := self perform: attribute.			Transcript show: ( attribute asString ),': ', ( value printShowingDecimalPlaces: 1   ), String space.				].	Transcript show: '}'; cr.	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2012 18:45'!setMaxFor: aSymbol to: anInteger	(self maximums ) at: aSymbol put: anInteger.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/30/2012 18:42'!setMinFor: aSymbol to: anInteger	(self minimums ) at: aSymbol put: anInteger.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 14:27'!setMinMaxLimits	"Parameters define the min and max for each degree of freedom"			"Lag :: Number of calendar days to use in moving average (going back from latest available day).	As a side effect, this also determines the amount of time before a strategy starts to operate."	self setMinFor: #lag to: 3.	self setMaxFor: #lag to: ( 217 ).		"weightPositive :: weight multiplier reflecting decision to buy when X is positive"	self setMinFor: #weightPositive to: 0.	self setMaxFor: #weightPositive to: 100.		"weightNegative :: weight multiplier reflecting decision to buy when X is negative"	self setMinFor: #weightNegative to: 0.	self setMaxFor: #weightNegative to: 100.		"percentCapital :: maximum percent of total capital to commit to a buy signal "	self setMinFor: #percentCapital to: 1.	self setMaxFor: #percentCapital to: 50.		"percentGain :: Sell a holding if price ascends above this level."	self setMinFor: #percentGain to: 1.	self setMaxFor: #percentGain to: 200.	"percentLoss :: Sell a holding if price descends below this level."	self setMinFor: #percentLoss to: 1.	self setMaxFor: #percentLoss to: 50.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/29/2013 22:24'!shortReport	"Report current parameter values"	|  attributes |	^ 'Strategy values { ',		 ' lag: ', ( lag printShowingDecimalPlaces: 0 ),		 ' w+ ', ( weightPositive printShowingDecimalPlaces: 1 ),		 '::', (weightNegative printShowingDecimalPlaces: 1 ),		 ' %$ ', ( percentCapital printShowingDecimalPlaces: 1 ),		 ' %G ', ( percentGain printShowingDecimalPlaces: 1 ),		 ' %L ', ( percentLoss printShowingDecimalPlaces: 1 ),		 ' # ', ( numberOfLives printShowingDecimalPlaces: 0 ),		 ' F ', (( self averageFitness ) printShowingDecimalPlaces: 2),  		 ' D ', ( self dayOfWeek asString ),		  ' }'.	! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:43'!weightNegative 	^weightNegative.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 10:10'!weightNegative: weight	"weight multiplier reflecting decision to buy when X is negative"	self assert: ( weight isKindOf: Number  ).	self assert: ( weight >= ( self getMinimumFor: #weightNegative  ) ).	self assert: ( weight <= ( self getMaximumFor: #weightNegative ) ).	weightNegative := weight.	weightPositive := 100 - weight.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/31/2012 10:43'!weightPositive 	^weightPositive.! !!Strategy methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 10:09'!weightPositive: weight	"weight multiplier reflecting decision to buy when X is positive"	self assert: ( weight isKindOf: Number   ).	self assert: ( weight >=  ( self getMinimumFor: #weightPositive   ) ).	self assert: ( weight <=  ( self getMaximumFor: #weightPositive ) ).	weightPositive := weight.	weightNegative := 100 - weight.! !!Strategy methodsFor: 'converting' stamp: 'RichardAlexanderGreen 1/25/2013 10:08'!mutatedByPercent: percent	"Create a version of self but with one attribute mutated.	The amount of mutation is limited by the given percentage.	"	| mutatedStrategy attributeToMutate currentValue plusOrMinus mutatedValue |	self assert: ( percent isKindOf: Number  ).	mutatedStrategy := self copy.	"Reset history"	numberOfLives := 0.	fitnessHistory := nil.	"Attribute to mutate"	attributeToMutate := ( self degreesOfFreedom ) atRandom.	plusOrMinus := #( 1.0 -1.0 ) atRandom.	currentValue := self perform: attributeToMutate.	mutatedValue := currentValue * ( 100 + ( plusOrMinus * percent ) )  / 100.	( mutatedValue < ( self getMinimumFor: attributeToMutate ) ) 		ifTrue: [ mutatedValue := ( self getMinimumFor:  attributeToMutate ) ].	( mutatedValue > ( self getMaximumFor: attributeToMutate ) ) 		ifTrue: [ mutatedValue := ( self getMaximumFor: attributeToMutate ) ].	self perform: (( attributeToMutate, ':' ) asSymbol) with: mutatedValue.	^mutatedStrategy.	! !TestCase subclass: #PortfolioTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 09:39'!test000TranscriptClear	Transcript clear.! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/4/2013 11:33'!test110CreatePortfolio	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 10.	portfolio standardFee: 7.		self assert: ( portfolio initialCapital = ( 100*1000 ) ).	self assert: ( portfolio purchaseLimitPercent = 10).		self assert: ( portfolio standardFee = 7 ).! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/4/2013 12:45'!test115DoWeAlreadyOwn	"We can ask if we already own a ticker."	| portfolio holding percentLoss day |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	"TODO: FORCE THE portfolio holdings"	holding := StockHolding new.	holding		ticker: 'DTE';		quantity: 100;		priceBot: 588.77; "This bogus price is here to force stop loss test."		whenBot: (Date year: 2012 month: 08 day: 26 ). 		( portfolio holdings ) at: 'DTE' put: holding.		self assert:  ( (portfolio holdings size) = 1 ).   		self assert: ( portfolio weAlreadyOwn: 'DTE'  ).	self assert: ( portfolio weAlreadyOwn: 'IBM'  ) not.	! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 10:50'!test120PurchaseTickerWithinLimit	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 10.	portfolio standardFee: 7.			portfolio purchase: 'DTE' onDay: ( Date year: 2007 month: 08 day: 31 ) orBefore: ( Date year: 2008 month: 08 day: 31).	self assert: ' Bot: 100 of: DTE at: 47.81 on: 31 August 2007' equals: ( portfolio log at: 1 ).		! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 10:51'!test125PurchaseDecrementsCashOnHand	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio cash |	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 10.	portfolio standardFee: 7.			portfolio purchase: 'DTE' onDay: ( Date year: 2007 month: 08 day: 31 ) orBefore: ( Date year: 2008 month: 08 day: 31 ).	self assert: ' Bot: 100 of: DTE at: 47.81 on: 31 August 2007' equals: ( portfolio log at: 1 ).		cash := portfolio cashOnHand.	self assert: ( cash isKindOf: Number  ).		self assert: ( cash < 100e3 ).! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 10:52'!test127SalesIncrementsCashOnHand	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio cash priorCashOnHand holding |	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 10.	portfolio standardFee: 7.			portfolio purchase: 'DTE' onDay: ( Date year: 2007 month: 08 day: 31 ) orBefore: ( Date year: 2008 month: 08 day: 31 ).	self assert: ' Bot: 100 of: DTE at: 47.81 on: 31 August 2007' equals: ( portfolio log at: 1 ).		cash := portfolio cashOnHand.	self assert: ( cash isKindOf: Number  ).		self assert: ( cash < 100e3 ).		"Now sell it can cash should be returned."	priorCashOnHand := cash.	portfolio sellTicker: 'DTE' on: (Date year: 2007 month: 09 day: 04 ).	cash := portfolio cashOnHand.	self assert: ( cash ) > priorCashOnHand.! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 10:53'!test130PurchaseTickerOverLimit	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 10.	portfolio standardFee: 7.			portfolio purchase: 'IBM' onDay: ( Date year: 2007 month: 08 day: 31 ) orBefore: ( Date year: 2008 month: 08 day: 31 ).	self assert: 				' Bot: 10 of: IBM at: 116.69 on: 31 August 2007' 				equals: ( portfolio log at: 1 ).	! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 10:54'!test140PurchaseTickerWayOverLimit	"When portfolio is created we need to define:	- initial capital: Cash initially allocated to portfolio	- purchase limit: Percent of initial capital that may be allocated to a single purchase (a single ticker)	"	| portfolio |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	portfolio purchase: 'MA' onDay: ( Date year: 2007 month: 08 day: 31 ) orBefore: ( Date year: 2008 month: 08 day: 31 ).	self assert: 				' Bot: 10 of: MA at: 136.99 on: 31 August 2007' 				equals: ( portfolio log at: 1 ).	! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/14/2013 10:54'!test220SellLosers	"Sell any holding whose current price is below the percentLoss given."	| portfolio holding percentLoss day |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	"TODO: FORCE THE portfolio holdings"	holding := StockHolding new.	holding		ticker: 'DTE';		quantity: 100;		priceBot: 588.77; "This bogus price is here to force stop loss test."		whenBot: (Date year: 2012 month: 08 day: 26 ). 		( portfolio holdings ) at: 'DTE' put:  holding.	self assert: ( portfolio weAlreadyOwn: 'DTE'   ). 		percentLoss := 10.	day := (Date year: 2007 month: 08 day: 27 ).	portfolio sellLosersBelow: percentLoss on: day.		"Confirm that log shows sale."	self assert: 			'Sold: 100 of: DTE at: 47.55 on: 27 August 2007 gain: -54122.00'			equals: ( portfolio log at: 1 ).		"Confirm that portfolio holdings no longer contains stock that was sold"	self assert: ( portfolio weAlreadyOwn: 'DTE'   ) not. 		"Confirm that holdings no long include that ticker"	self assert: ( (portfolio  holdings)  isEmpty ).		"Confirm that prior holding contain something."	self assert: ( (portfolio priorHoldings) size > 0 ).! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 11:22'!test230SellWiners	"Sell any holding whose current price is below the percentGain given."	| portfolio holding percentGain day |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	"TODO: FORCE THE portfolio holdings"	holding := StockHolding new.	holding		ticker: 'DTE';		quantity: 100;		priceBot: 33.33; "This bogus price is here to force  test."		whenBot: (Date year: 2001 month: 08 day: 26 ). 		( portfolio holdings ) at: 'DTE' put:  holding.	self assert: ( portfolio weAlreadyOwn: 'DTE'   ). 		percentGain := 10.	day := (Date year: 2007 month: 08 day: 27 ).	portfolio sellWinersAbove: percentGain on: day.		"Confirm that log shows sale."	self assert: 				'Sold: 100 of: DTE at: 47.55 on: 27 August 2007 gain: 1422.00'				equals: ( portfolio log at: 1 ).		"Confirm that portfolio holdings no longer contains stock that was sold"	self assert: ( portfolio weAlreadyOwn: 'DTE'   ) not. 		"Confirm that holdings no long include that ticker"	self assert: ( (portfolio  holdings)  isEmpty ).! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 08:56'!test310ShowLog	"Sell any holding whose current price is below the percentGain given."	| portfolio  percentGain   |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	"TODO: FORCE THE portfolio holdings"	portfolio purchase: 'DTE' onDay: (Date year: 2007 month: 08 day: 24 ) orBefore: (Date year: 2001 month: 08 day: 24 ).	percentGain := 10.	portfolio sellTicker: 'DTE' on: (Date year: 2007 month: 08 day: 31 ).			Transcript cr; show: 'test310ShowLog'.	portfolio listLogOnTranscript.! !!PortfolioTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 08:56'!test320ReportPriorHoldings	"Sell any holding whose current price is below the percentGain given."	| portfolio  percentGain  stream |	portfolio := Portfolio new.	portfolio initialCapital: 100*1000.	portfolio purchaseLimitPercent: 3.	portfolio standardFee: 7.	"TODO: FORCE THE portfolio holdings"	portfolio purchase: 'DTE' onDay: (Date year: 2007 month: 08 day: 24 ) orBefore: (Date year: 2001 month: 08 day: 24 ).	percentGain := 10.	portfolio sellTicker: 'DTE' on: (Date year: 2007 month: 08 day: 31 ).			self assert: ( portfolio priorHoldings size > 0 ).		Transcript cr; show: 'test320ReportPriorHoldings'.	self halt.	portfolio reportPriorHoldings.! !Object subclass: #StockHolding	instanceVariableNames: 'priceBot priceSold ticker whenBot whenSold quantity dividends fees'	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!StockHolding commentStamp: 'RichardAlexanderGreen 12/29/2012 13:11' prior: 0!"Instances represent a stock holding that has been purchased (bot) but may or may not have been sold.Instance Variables:	id			<UUID>	ticker	      <String>	quantity	<Number>	whenBot	<Date>	priceBot	<Number>	whenSold	<Date>	priceSold	<Number>	fees		<Number>	dividends	<Number>		"!!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:39'!addDividend: dividendPerShare 	"Add dividend to the dividends total - "	dividends := dividends + ( dividendPerShare * quantity ).! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:40'!addFee: aFloat 	"Add the given fee -- typically a brokerage buy/sell fee."	fees := fees + aFloat .! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/14/2013 10:05'!daysHeld	"Calculate the number of days the holding was held."	| duration days |	self assert: whenSold notNil.	duration := whenSold - whenBot.	days := duration days.	^days.	! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:58'!dividends	^ dividends! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:39'!dividends: aFloat 	"Set the dividends accrued -- see also: addDividend: "	dividends := aFloat.! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:56'!fees	^ fees! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:35'!fees: aFloat 	fees := aFloat .! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:44'!gain	| gross net |	"Only valid after holding is sold"	priceSold ifNil: [ ^nil ].	"Gross profit/loss before fees and dividends"	gross := quantity * ( priceSold - priceBot ).	"Net after fees and dividends"	net := gross + dividends - fees.	^net.	! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:31'!id	^ id ifNil: [ id := UUID new ].! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 13:05'!initialize 	"These should be zero. Other attributes may be nil at first."	quantity := 0.0.	priceBot := 0.0.	dividends := 0.0.	fees := 0.0.	"NOTE: priceSold is used as a semaphore"	priceSold := nil.! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:35'!priceBot	^priceBot! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:34'!priceBot: aFloat 	"Price per share when purchased."	priceBot := aFloat .! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:35'!priceSold: aFloat 	"Price per share when sold."	priceSold := aFloat .! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 12:21'!quantity	^ quantity! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:36'!quantity: anInteger 	"Quantity purchased and held."	quantity := anInteger.	! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:35'!ticker	^ticker! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 12:32'!ticker: aString 	ticker := aString.	! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:36'!whenBot: aDate 	"Date when purchased."	whenBot := aDate.! !!StockHolding methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/3/2013 23:36'!whenSold: aDate 	"Date when sold."	whenSold := aDate .! !!StockHolding methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/14/2013 10:19'!report 	"Report the holding in a readable format -- prefer one line that keeps columns aligned."	| string space |	string := String new.	space := String space.	string := string, whenBot yyyymmdd, space, whenSold yyyymmdd.	string := string, space, quantity asString, '@'.	string := string, space, (priceBot printShowingDecimalPlaces: 2), space, (priceSold printShowingDecimalPlaces: 2).	string := string, space, ticker.	string := string, space, ( (self gain) printShowingDecimalPlaces: 2  ).		^string.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StockHolding class	instanceVariableNames: 'portfolio'!!StockHolding class methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/7/2013 11:21'!purchased: aString quantity: anInteger on: aDate for: purchasePrice	"Add the given purchase to the portfolio"	| newHolding |	newHolding := StockHolding new.	newHolding		ticker: aString;		quantity: anInteger;		priceBot: purchasePrice;		whenBot: aDate.  	"	(self portfolio) at: aString put: newHolding.	"	^ newHolding.	! !!StockHolding class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 13:26'!clearPortfolio	"Primarily for debug -- Set portfolio nil to force re-initialization.	WARNING: ALL DATA WILL BE CLEARED"	portfolio := nil.! !!StockHolding class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 13:24'!forTicker: aString 	^( self portfolio ) at: aString ifAbsent: [ nil ].! !!StockHolding class methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 12/29/2012 13:24'!portfolio	^ portfolio ifNil: [ portfolio := Dictionary new ].! !TestCase subclass: #StrategyTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 09:39'!test000TranscriptClear	Transcript clear.! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/18/2013 10:47'!test110StrategyScore	"A strategy gives a score for a given stock history.	The score is strongly positive when the strategy thinks we should buy or hold the stock.	"	| score history strategy |	false ifFalse: [ Transcript cr; show: 'test110StrategyScore is turned off'. ^self ].	"Get a history up through some date."	history := DailyStat getHistoryForTicker: 'DTE' until: ( Date year: 2012 month: 08 day: 31 ).	strategy := Strategy new.	"Note that the strategy does not know the ticker.  It is name-blind."	score := strategy scoreFor: history.	self assert: ( score isKindOf: Number ).			! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/13/2013 18:09'!test111StrategyScore	"A strategy gives a score for a given stock history.	The score is strongly positive when the strategy thinks we should buy or hold the stock.	When funds are available to invest, the top scoring tickers would be the ones to consider.	"	| score  strategy |	"Get a history up through some date."	strategy := Strategy new.	strategy randomize.	"Note that the strategy does not know the ticker.  It is name-blind."	score := strategy scoreForTicker: 'DTE' 						from: (Date year: 2007 month: 01 day: 02) 						until: ( Date year: 2009 month: 12 day: 31 ).	self assert: ( score isKindOf: Number ).			! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/31/2012 10:07'!test120StrategyFactors	"Strategy depends on a variety of factors (Degrees Of Freedom)."	|  strategy  degreesOfFreedom |	strategy := Strategy new.			"Confirm that the degreesOfFreedom include . . .."	degreesOfFreedom := strategy degreesOfFreedom.	self assert: ( degreesOfFreedom isKindOf: Collection  ).	self assert: ( degreesOfFreedom isEmpty not ).	self assert: ( degreesOfFreedom  includes: #lag ).	self assert: ( degreesOfFreedom  includes: #percentLoss ).	self assert: ( degreesOfFreedom  includes: #percentGain ).	self assert: ( degreesOfFreedom  includes: #percentCapital ).	self assert: ( degreesOfFreedom  includes: #weightNegative ).	self assert: ( degreesOfFreedom  includes: #weightPositive ).		! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/31/2012 10:48'!test130StrategyRanges	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.			"Each degree of freedom has a minimum and maximum value"	degreesOfFreedom := strategy degreesOfFreedom.	self assert: ( degreesOfFreedom size > 5 ).	degreesOfFreedom 		do: [ :factor |			|  min max |			min := strategy getMinimumFor: factor.  			max := strategy getMaximumFor: factor.  			self assert: ( min < max ).  			].		! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/9/2013 17:18'!test135DegreesOfFreedomReport	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.		strategy degreesOfFreedomReport.	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 12/31/2012 10:50'!test140StrategyQuery	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.	strategy randomize.			"Confirm that randomized value are in proper range."	degreesOfFreedom := strategy degreesOfFreedom.	self assert: ( degreesOfFreedom size > 5 ).	degreesOfFreedom 		do: [ :factor |			|  min max value |			min := strategy getMinimumFor: factor.  			max := strategy getMaximumFor: factor.  			self assert: ( min < max ).  			value := strategy perform: factor.			self assert: ( value isKindOf: Integer  ).			self assert: ( value >= min ).			self assert: ( value <= max ).			].		! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/25/2013 09:55'!test145AverageFitness	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.	strategy randomize.			strategy addFitness: 1.10.	strategy addFitness: 0.90.		self assert: 1.00 equals: ( strategy averageFitness ).	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/9/2013 17:06'!test150Report	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.	strategy randomize.			strategy report.	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/25/2013 10:02'!test160ShortReport	"Strategy depends on a variety of factors that may be varied to create competing strategies."	|  strategy degreesOfFreedom  |	strategy := Strategy new.	strategy randomize.		strategy addFitness: 1.10.	strategy addFitness: 0.90.	  			Transcript show: 'test160ShortReport: ', (strategy shortReport).	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:57'!test210RunStrategy	"Run a strategy against a sample of tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio sampleTickers startDate endDate markToMarket fitness  |		Transcript cr; show: 'Running test210RunStrategy'; cr.	"Get a sample of the available tickers."	sampleTickers := DailyStatMatrix  sampleTickersOfSize: 10.	self assert: ( sampleTickers size = 10 ).		"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	strategy := Strategy new.	strategy 		lag: 60;		percentCapital: 2;		weightNegative: 8;		weightPositive: 92;		percentLoss: 5;		percentGain: 75.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: sampleTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test210RunStrategy markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test210RunStrategy fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).				"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains.   	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:57'!test220RunStrategyOnWednesdays	"Run a strategy against a sample of tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio sampleTickers startDate endDate markToMarket fitness  |		Transcript cr; show: 'Running test220RunStrategyOnWednesdays'; cr.	"Get a sample of the available tickers."	sampleTickers := DailyStatMatrix  sampleTickersOfSize: 10.	self assert: ( sampleTickers size = 10 ).		"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	strategy := Strategy new.	strategy 		dayOfWeek: 4;		lag: 60;		percentCapital: 2;		weightNegative: 8;		weightPositive: 92;		percentLoss: 5;		percentGain: 75.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: sampleTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test220RunStrategyOnWednesdays markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test220RunStrategyOnWednesdays fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).				"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains .   	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:58'!test310RunStrategyOnAllTickers	"Run a strategy against all tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio allTickers startDate endDate markToMarket fitness  |		false 		ifTrue: [ Transcript cr; show: 'Running test310RunStrategyOnAllTickers'; cr. ] 		ifFalse: [ Transcript cr; show: ' test310RunStrategyOnAllTickers turned off'; cr.  ^self ].   		"Get univers of the available tickers."	allTickers := DailyStatMatrix tickers keys asSet.			"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	strategy := Strategy new.	strategy 		lag: 60;		percentCapital: 2;		weightNegative: 8;		weightPositive: 92;		percentLoss: 5;		percentGain: 75.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: allTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test310RunStrategyOnAllTickers markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test310RunStrategyOnAllTickers fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).				"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains .   	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:58'!test311RunStrategyOnAllTickers	"Run a strategy against all tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio allTickers startDate endDate markToMarket fitness  |		true 		ifTrue: [ Transcript cr; show: 'Running test311RunStrategyOnAllTickers'; cr. ] 		ifFalse: [ Transcript cr; show: ' test311RunStrategyOnAllTickers turned off'; cr.  ^self ].  		"Get univers of the available tickers."	allTickers := DailyStatMatrix tickers keys asSet.			"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	"lag: 3 w+ 94.9::5.1 %$ 8.9 %G 54.6 %L 4.5 # 4 F 1.08"	strategy := Strategy new.	strategy 		lag: 3;		percentCapital: 2;		weightNegative: 5;		weightPositive: 95;		percentLoss: 4;		percentGain: 55.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: allTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test311RunStrategyOnAllTickers markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test311RunStrategyOnAllTickers fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).			"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains .   ! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:58'!test320RunStrategyOnWednesdaysOverAllTickers	"Run a strategy against all tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio allTickers startDate endDate markToMarket fitness  |		false 		ifTrue: [ Transcript cr; show: 'Running test320RunStrategyOnWednesdaysOverAllTickers'; cr. ] 		ifFalse: [ Transcript cr; show: ' test320RunStrategyOnWednesdaysOverAllTickers turned off'; cr.  ^self ].   		"Get univers of the available tickers."	allTickers := DailyStatMatrix tickers keys asSet.			"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	strategy := Strategy new.	strategy 		dayOfWeek: 4;  		lag: 60;		percentCapital: 2;		weightNegative: 8;		weightPositive: 92;		percentLoss: 5;		percentGain: 75.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: allTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test320RunStrategyOnWednesdaysOverAllTickers markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test320RunStrategyOnWednesdaysOverAllTickers fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).				"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains .   	! !!StrategyTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/15/2013 09:58'!test321RunStrategyOnAllTickersBuyOnlyOnWednesday	"Run a strategy against all tickers for a period of time.	At the end of the period, look at the value of the portfolio.	"	| strategy portfolio allTickers startDate endDate markToMarket fitness  |		false 		ifTrue: [ Transcript cr; show: 'Running test321RunStrategyOnAllTickersBuyOnlyOnWednesday'; cr. ] 		ifFalse: [ Transcript cr; show: ' test321RunStrategyOnAllTickersBuyOnlyOnWednesday turned off'; cr.  ^self ].  		"Get univers of the available tickers."	allTickers := DailyStatMatrix tickers keys asSet.			"Create and endow a portfolio "	portfolio := Portfolio new.	portfolio initialCapital: 100e3.	portfolio purchaseLimitPercent: 5.	portfolio standardFee: 7.		"Run strategy against the sample tickers from a period of time."	"lag: 3 w+ 94.9::5.1 %$ 8.9 %G 54.6 %L 4.5 # 4 F 1.08"	strategy := Strategy new.	strategy 		dayOfWeek: 4; 		lag: 3;		percentCapital: 2;		weightNegative: 5;		weightPositive: 95;		percentLoss: 4;		percentGain: 55.	strategy check.    		startDate := ( Date year: 2007 month: 06 day: 01 ).	endDate := ( Date year: 2008 month: 05 day: 30 ).	fitness := strategy runForTickers: allTickers from: startDate until: endDate inPortfolio: portfolio.		self assert: ( portfolio cashOnHand <= 100e3 ).	markToMarket := portfolio markToMarketOnDate: endDate .	Transcript cr; show: 'In test321RunStrategyOnAllTickersBuyOnlyOnWednesday markToMarket = ', ( markToMarket printShowingDecimalPlaces: 2 ).	Transcript cr; show: 'In test321RunStrategyOnAllTickersBuyOnlyOnWednesday fitness = ', ( fitness printShowingDecimalPlaces: 2 ).	self assert: ( markToMarket > 0  ).		"Want to see the action"	portfolio sellEverythingOn: endDate.	portfolio reportLossesVsGains.   	! !Object subclass: #Portfolio	instanceVariableNames: 'holdings initialCapital purchaseLimitPercent standardFee log cashOnHand priorHoldings'	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 12:50'!cashOnHand	"Cash on hand reflected initial capital and is decremented by purchases, 	incremented by sales."	^ cashOnHand.! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/7/2013 18:08'!cashOnHand: aSmallInteger 	cashOnHand := aSmallInteger! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/7/2013 18:54'!check	"Check that all needed parameters are set."	| needed |	needed := #( #initialCapital #purchaseLimitPercent #cashOnHand #standardFee  ).	needed		do: [ :attribute |			| value |			value := self perform: attribute.			self assert: ( value isNil not  ).			].	! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 12:35'!holdings	^ holdings ifNil: [ holdings := Dictionary new ].! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 11:00'!initialCapital	^ initialCapital! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 12:51'!initialCapital: anlInteger 	"How many dollars are allocated initially -- This affects purchase limits.	See also: purchaseLimitPercent	"	initialCapital := anlInteger.	cashOnHand := initialCapital. 	! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/13/2013 14:18'!listLogOn: aStream	"List the contents of the log on the given stream"	| cr |	cr := String cr.	( self log )		do: [ :entry |			aStream nextPutAll: ( entry, cr ).  			].! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 2/14/2013 10:31'!listLogOnTranscript	"List the contents of the log on the given stream"	| cr |	cr := String cr.	( self log )		do: [ :entry |			Transcript cr; show: entry.  			].! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 11:47'!log	^log ifNil: [ log := OrderedCollection new. ].! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/10/2013 12:10'!priorHoldings	^ priorHoldings ifNil: [ priorHoldings := OrderedCollection new ].! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 11:00'!purchaseLimitPercent	^ purchaseLimitPercent! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 10:59'!purchaseLimitPercent: aSmallInteger 	"How much of initial capital might be allocated to a single stock purchase?"	purchaseLimitPercent := aSmallInteger 	! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 11:29'!standardFee	^ standardFee.! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/4/2013 11:34'!standardFee: aSmallInteger 	standardFee := aSmallInteger! !!Portfolio methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/18/2013 15:17'!transactions 	"Return the count of the number of holdings bot and sold over time."	| count |	count := ( self holdings size ) + ( self priorHoldings size ).	^count! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/18/2013 12:35'!getPriceForTicker: aTicker on: datePreferred until: dateEnd 	| price onDate priceMatrix |	priceMatrix := DailyStatMatrix called: #close.		onDate := datePreferred.	price := priceMatrix forTicker: aTicker  date: onDate.   	[ price isNil ]		whileTrue: [			onDate := DailyStatMatrix nextBusinessDayAfter: onDate.			price :=  priceMatrix forTicker: aTicker  date: onDate.			( onDate > dateEnd ) ifTrue:[ ^ { nil. onDate } ].			].		^ { price. onDate. }.! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/18/2013 12:54'!markToMarketOnDate: aDate	"Compute what the current holdings would be worth at given date.	Add cash on hand.	"	| valuation markToMarket |	valuation := 0.0.	self holdings		do: [ :holding |			| ticker limitDay priceOnDate currentPriceOfHolding shares |			ticker := holding ticker.  			limitDay := aDate addDays: 7.  			priceOnDate := self getPriceForTicker: ticker on: aDate until: ( aDate addDays: 7  ).			currentPriceOfHolding := priceOnDate at: 1.			currentPriceOfHolding ifNil: [ self log: 'No mark to market for: ', ticker ]				ifNotNil: [					shares := holding quantity.					valuation := valuation + ( currentPriceOfHolding * shares ).					].   						].	markToMarket := valuation + cashOnHand.	^markToMarket.! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 2/14/2013 10:26'!sellEverythingOn: aDate 	"Sell any holding whose current price is below the percentGain given."	| holdingsCopy |	self check.	holdings := (self holdings ) copy.	holdings		do: [ :holding |			| ticker  purchasePrice priceOnDate currentPrice |			self assert: ( holding isKindOf: StockHolding  ).			"Get ticker"			ticker := holding ticker.			"Get current / lastest price"			" priceOnDate is tuple: { price. onDate. }"			priceOnDate := self getPriceForTicker: ticker on: aDate until: ( aDate addDays: 7  ).			currentPrice := priceOnDate at: 1.			currentPrice ifNil: [ Error signal: 'Cannot sell because there are no prices for a whole week?' ].			"Get purchase price"			purchasePrice := holding priceBot.   			self sellHolding: holding on: (priceOnDate at: 2).			].	! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/20/2013 23:04'!sellLosersBelow: percentLoss on: aDate	"Sell any holding whose current price is below the percentLoss given."	| holdingsCopy |	self check.	holdings := (self holdings ) copy.	holdings		do: [ :holding |			| ticker  purchasePrice currentPrice priceOnDate ratio |			self assert: ( holding isKindOf: StockHolding  ).			"Get ticker"			ticker := holding ticker.			"Get current / lastest price"			priceOnDate := self getPriceForTicker: ticker on: aDate until: ( aDate addDays: 7  ).			currentPrice := priceOnDate at: 1.			currentPrice ifNil: [ 				"Error signal: 'Cannot sell because there are no prices for a whole week?'."				currentPrice := 0.0 ].			"Get purchase price"			purchasePrice := holding priceBot.   			"Comute current / purchased"			ratio := currentPrice / purchasePrice.			"If ratio is less than one minus percentLoss, sell this holding."			( ratio < (1.0 - ( percentLoss  / 100.0 ) ) )				ifTrue: [ self sellHolding: holding on: (priceOnDate at: 2) ].			].	! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 2/14/2013 10:26'!sellWinersAbove: percentGain on: aDate 	"Sell any holding whose current price is below the percentGain given."	| holdingsCopy |	self check.	holdings := (self holdings ) copy.	holdings		do: [ :holding |			| ticker  purchasePrice priceOnDate currentPrice ratio |			self assert: ( holding isKindOf: StockHolding  ).			"Get ticker"			ticker := holding ticker.			"Get current / lastest price"			" priceOnDate is tuple: { price. onDate. }"			priceOnDate := self getPriceForTicker: ticker on: aDate until: ( aDate addDays: 7  ).			currentPrice := priceOnDate at: 1.			currentPrice ifNil: [ Error signal: 'Cannot sell because there are no prices for a whole week?' ].			"Get purchase price"			purchasePrice := holding priceBot.   			"Comute current / purchased"			ratio := currentPrice / purchasePrice.			"If ratio is less than one minus percentGain, sell this holding."			( ratio > (1.0 + ( percentGain  / 100.0 ) ) )				ifTrue: [ self sellHolding: holding on: (priceOnDate at: 2) ].			].	! !!Portfolio methodsFor: 'evaluating' stamp: 'RichardAlexanderGreen 1/4/2013 12:43'!weAlreadyOwn: aTicker	"Answer true if we already own"	| answer holding |	answer := false.	holding := ( self holdings ) at: aTicker  ifAbsent: [ nil ].	answer := holding notNil.	^ answer.! !!Portfolio methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/10/2013 14:05'!considerPurchasing: candidates onDate: aDate	"Consider purchasing one of the candidates in the given set of ( ticker -> score )"	| |	self assert: ( candidates isKindOf: Set  ).	"For each ticker sorted by highest score:	. If we already own it:	. . Do nothing.	. Otherwise:	. . If we have sufficient funds to buy 100 shares:	. . . Purchase the stock. (Get next day's price from the database.)	"  	candidates		do: [ :candidate | 			| ticker |			self assert: ( candidate isKindOf: Association ).			ticker := candidate key.			"Do we already own it?"			( self weAlreadyOwn: ticker )				ifFalse: [					self purchase: ticker onDay: aDate orBefore: ( aDate addDays: 30 ).					].			].	! !!Portfolio methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/28/2013 07:15'!purchase: aTicker onDay: aDay orBefore: aLastDay	"Purchase 100 shares of that ticker (if we have sufficient funds.)	Rules: 	A: Do not allocate more than X% of initial capital to a single stock.	. If 100 * price > 10% of our initial capital. (example 10% of $100k is $10k):	. . Consider purchasing 10 shares.	. . . If 10* price > 10% of our initial capital:	. . . . Consider purchasing 1 share.	. . . . If 1 * price > 10% of our initial capital:	. . . . . Forget it.	. That percentage X% is set when portfolio is created.	. The initial capitla is set when portfolio is created.	B: We do not buy what we already own.	. It is caller`s responsibility to assure we do not already own this stock.	C: Add a standard fee to StockHolding.	. This fee is defined when the portfolio is created.	D: We cannot buy if there is not sufficient cash-on-hand on this date.	. TODO: Assume cash-on-hand is not updated immediately when we sell losers.	"	| purchasePrice considerInvesting stat purchaseDay |	self assert: ( aTicker isKindOf: String ).	self assert: ( aDay isKindOf: Date ).	self assert: ( aLastDay isKindOf: Date ).	self assert: ( ( self weAlreadyOwn: aTicker ) not  ).	self check.		purchasePrice := (DailyStatMatrix called: #close) forTicker: aTicker date: aDay.   	purchasePrice ifNil: [ "Too thin ==> Don't buy"		Transcript cr; show: aTicker, ' is too thin. **REMOVING FROM TICKERS ***'; cr. 		DailyStatMatrix removeTicker: aTicker  faultDate: aDay  because:   'No price for purchase in range.'.		^self		].	self assert: ( purchasePrice notNil ).  	purchaseDay := aDay.	self assert: ( purchaseDay notNil ).	#( 100 10 1 )		do: [ :shares |			"Considering purchasing N shares"			( ( shares * purchasePrice ) < ( initialCapital * purchaseLimitPercent / 100 ) )				ifTrue: [ | newHolding |					newHolding := StockHolding purchased: aTicker  quantity: shares on: purchaseDay for: purchasePrice. 					newHolding addFee: ( self standardFee ).					(self holdings ) at: aTicker put: newHolding.					cashOnHand := cashOnHand - ( shares * purchasePrice ) - ( self standardFee  ).					self log: ' Bot: ', (shares asString)								, ' of: ', aTicker								,' at: ', ( purchasePrice printShowingDecimalPlaces: 2  )								,' on: ', ( purchaseDay asString ).					^self.					].			].! !!Portfolio methodsFor: 'locales' stamp: 'RichardAlexanderGreen 2/13/2013 17:36'!sellHolding: aStockHolding on: aDate	" Sell the given holding. 	Remove it from current list of holdings. 	Move to soldHoldings."	| ticker shares currentPrice  gainLoss purchasePrice |	"Log sale."	self check.	self assert: ( aStockHolding isKindOf: StockHolding ).	self assert: ( aDate isKindOf: Date ).	ticker := aStockHolding ticker.	shares := aStockHolding quantity.  	currentPrice := (DailyStatMatrix called: #close) forTicker: ticker date: aDate.	currentPrice ifNil: [ 			"See if there is a price anytime for the next 9 weeks."			 (DailyStatMatrix called: #close)	 				forEachDayInHistoryOf: ticker from: aDate  until: (aDate addDays: (9*7)  ) 					do: [ :price | (price notNil and: [currentPrice isNil ]) ifTrue: [currentPrice := price] ].       				currentPrice ifNil: [ "Somehow we bot a ticker that got unlisted or something." 						DailyStatMatrix removeTicker: ticker faultDate: aDate because: 'No price for sellHolding.'.						currentPrice := 0.0						].			 ].  	purchasePrice := aStockHolding priceBot.	gainLoss := ( currentPrice - purchasePrice ) * shares.	self log: 'Sold: ', ( shares asString )			, ' of: ', ticker			,' at: ', ( currentPrice printShowingDecimalPlaces: 2  )			, ' on: ', ( aDate asString )			,' gain: ', ( gainLoss printShowingDecimalPlaces: 2 )			.		"Remove given stock holding from current holdings"	(self holdings) removeKey: ticker.		"Add to priorHoldings"	aStockHolding 		priceSold: currentPrice;		whenSold: aDate.  		( self priorHoldings ) add: aStockHolding.		"Update cash on hand."	cashOnHand := cashOnHand + ( shares * currentPrice ) - ( self standardFee ).! !!Portfolio methodsFor: 'locales' stamp: 'RichardAlexanderGreen 2/14/2013 10:57'!sellTicker: aTicker on: aDate	" Sell the given holding. 	Remove it from current list of holdings. 	Move to soldHoldings."	| ticker holding shares currentPrice |	"Log sale."	self check.	self assert: ( aTicker isKindOf: String  ).	holding := self holdings at: aTicker.	self assert: ( holding isKindOf: StockHolding ).	self assert: ( aDate isKindOf: Date ).	ticker := holding ticker.	shares := holding quantity.  	self sellHolding: holding on:  aDate. 	! !!Portfolio methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 1/18/2013 12:56'!log: aString 	"Add the message string to the log.	Note:  This log is intended for test / debug, not audit.	TODO: Add a persistent audit-trail when that becomes relevant.	"	( self log ) add: aString.	"	Transcript cr; show: 'Portfolio log: ', aString.	"	! !!Portfolio methodsFor: 'printing' stamp: 'RichardAlexanderGreen 2/15/2013 09:59'!reportLossesVsGains	"Show report for each holding"	| countLosers countWinners losses gains |	countLosers := 0.	countWinners := 0.	losses := 0.00.	gains := 0.00.	( self priorHoldings ) 		do: [ :holding |			"Transcript cr; show: holding report."			"Tally losers versus winners"			( holding gain < 0 )				ifTrue: [ countLosers := countLosers + 1.					losses := losses + ( holding gain ).					] 				ifFalse: [ countWinners := countWinners + 1.					gains := gains + ( holding gain ).					].			].		"Report tallies."	Transcript cr; show: 'loses: ', countLosers asString, ' ', ( losses printShowingDecimalPlaces: 2  ).	Transcript cr; show: 'gains:  ', countWinners asString, '  ', ( gains printShowingDecimalPlaces: 2  ).! !!Portfolio methodsFor: 'printing' stamp: 'RichardAlexanderGreen 2/15/2013 09:59'!reportPriorHoldings	"Show report for each holding"	| countLosers countWinners losses gains |	countLosers := 0.	countWinners := 0.	losses := 0.00.	gains := 0.00.	( self priorHoldings ) 		do: [ :holding |			Transcript cr; show: holding report.			"Tally losers versus winners"			( holding gain < 0 )				ifTrue: [ countLosers := countLosers + 1.					losses := losses + ( holding gain ).					] 				ifFalse: [ countWinners := countWinners + 1.					gains := gains + ( holding gain ).					].			].		"Report tallies."	Transcript cr; show: 'loses: ', countLosers asString, ' ', ( losses printShowingDecimalPlaces: 2  ).	Transcript cr; show: 'gains:  ', countWinners asString, '  ', ( gains printShowingDecimalPlaces: 2  ).! !TestCase subclass: #DailyStatMatrixTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/11/2013 19:19'!pareto: countDictionary	"Make a crude pareto chart"	| sorted tab |	tab := String tab.	self assert: ( countDictionary isKindOf: Dictionary   ).	"Sort into descending order by count."	sorted := (countDictionary associations) sorted: [ :mapA :mapB | (( mapA value  ) > (mapB value)) ].	"Show only the top 20."	(sorted copyFrom: 1 to: 20)   		do: [ :map |			| key value |			key := map key.			value := map value.			Transcript cr; show: ( key asString ), ': ', tab, ( value asString ), tab,('|' padded: #right to: ((value / 50.0 ) floor) with: $] ).			].! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/11/2013 18:59'!reportCounts: countDictionary	"Make a crude histogram"	self assert: ( countDictionary isKindOf: Dictionary   ).		countDictionary 		keysAndValuesDo: [ :key : value |			Transcript cr; show: ( key asString ), ': ', value asString, ('|' padded: #right to: ((value / 50.0 ) floor) with: $] ).			].  	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/15/2013 14:17'!test000TranscriptClear	Transcript clear.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/18/2013 12:16'!test110ParseLine	"Given standard data line, parse it into fields."	|   dataLine columns fields  |	dataLine := 'AAP,20120917,67.57,69.04,67.53,67.89,777000'.	columns := #( #ticker #day #open #high #low #close #volume ).	fields := DailyStatMatrix parseLine: dataLine intoDailyStatFields: columns.		self assert: ( fields isKindOf: Dictionary  ).	self assert: ( fields at: #ticker ) = 'AAP'.	self assert: ( fields at: #day ) = '20120917'.	self assert: ( fields at: #open ) = '67.57'.		self assert: ( fields at: #high ) = '69.04'.	self assert: ( fields at: #low ) = '67.53'.	self assert: ( fields at: #volume ) = '777000'.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 18:57'!test120Insert	"Insert a record"	|   dataLine columns fields db history matrixX x ticker field date matrixY y |	"Provide test data"	dataLine := 'AAP,20070917,67.57,69.04,67.53,67.89,777000'.	columns := #( #ticker #day #open #high #low #close #volume ).		"Parse it"	fields := DailyStatMatrix parseLine: dataLine intoDailyStatFields: columns.		"Insert this close into matrix"	matrixX := DailyStatMatrix called: #close.	self assert: ( matrixX isKindOf: DailyStatMatrix ).	x := (fields at: #close) asNumber.	ticker := fields at: #ticker.	date := DailyStatMatrix dateFromYYYYMMDD: (fields at: #day).	matrixX insert: x forTicker: ticker date: date..		"Confirm: Get x back"	matrixY :=  DailyStatMatrix called: #close.	y := matrixY forTicker: ticker date: date.	self assert: x equals: y.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/15/2013 15:05'!test210OpenFile	"Open a file in the investment source files directory"	| file |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2012/NYSE_20120102.txt'.	self assert: ( file size > 0 ).! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/15/2013 15:05'!test220FirstLineIsHeader	"Open a file in the investment source files directory"	| file firstLine |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2012/NYSE_20120102.txt'.	self assert: ( file size > 0 ).		firstLine := file nextLine.	self assert: ( firstLine = '<ticker>,<date>,<open>,<high>,<low>,<close>,<vol>' ).! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/15/2013 15:06'!test225SecondLineIsData	"Open a file in the investment source files directory"	| file firstLine secondLine columns fields stat |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2012/NYSE_20120102.txt'.	self assert: ( file size > 0 ).		firstLine := file nextLine.	self assert: ( firstLine = '<ticker>,<date>,<open>,<high>,<low>,<close>,<vol>' ).		secondLine := file nextLine.	columns := #( #ticker #day #open #high #low #close #volume ).	fields := DailyStatMatrix parseLine: secondLine intoDailyStatFields: columns.		"Not very interresting data, but here it is."	self assert: ( fields isKindOf: Dictionary  ).	self assert: ( fields at: #ticker ) = 'A'.	self assert: ( fields at: #day ) = '20120102'.	self assert: ( fields at: #open ) = '34.93'.		self assert: ( fields at: #high ) = '34.93'.	self assert: ( fields at: #low ) = '34.93'.	self assert: ( fields at: #volume ) = '0'.	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 16:28'!test310OpenZipFile	"Open a zip file in the investment source files directory"	| file archive |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	self assert: ( file size > 0 ).	self assert: ( ZipArchive isZipArchive: file ).! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 16:28'!test320GetZipFileMembers	"Read a zip in the investment source files directory"	| file archive |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	self assert: ( file size > 0 ).	self assert: ( ZipArchive isZipArchive: file ).		archive := ZipArchive new.	archive readFrom: file.	self assert: ( archive members size > 0 ).	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 16:28'!test330CheckFileMembers	"Read a zip in the investment source files directory"	| file archive |	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	self assert: ( file size > 0 ).	self assert: ( ZipArchive isZipArchive: file ).		archive := ZipArchive new.	archive readFrom: file.	self assert: ( archive members size > 0 ).		archive members		do: [ :member |			| bigString tempStream firstLine |			bigString := member contents.			tempStream := ReadStream on: bigString.			firstLine := tempStream nextLine.			self assert: ( firstLine = '<ticker>,<date>,<open>,<high>,<low>,<close>,<vol>' ).			].		! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 18:32'!test340LoadDataFromZipArchive	"Read a zip in the investment source files directory"	| file archive |	false ifFalse: [ Transcript cr; show: 'test340LoadDataFromZipArchive has been turned off'. ^self.]		ifTrue: [ Transcript cr; show: 'Runningtest340LoadDataFromZipArchive '; cr ].	file := StandardFileStream readOnlyFileNamed: '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	self assert: ( file size > 0 ).	self assert: ( ZipArchive isZipArchive: file ).		archive := ZipArchive new.	archive readFrom: file.	self assert: ( archive members size > 0 ).		archive members		do: [ :member |			| bigString tempStream firstLine |			Transcript cr; show: 'Loading data from: ', (member fileName).			bigString := member contents.			tempStream := ReadStream on: bigString.			firstLine := tempStream nextLine.			self assert: ( firstLine = '<ticker>,<date>,<open>,<high>,<low>,<close>,<vol>' ).			DailyStatMatrix loadDataFromStream: tempStream.			self assert: ( tempStream atEnd ).			].		! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/9/2013 10:51'!test350LoadDataFromZipArchive	"Read a zip file  in the investment source files directory"	| aFileName |		false ifFalse: [ Transcript cr; show: 'test350LoadDataFromZipArchive has been turned off'. ^self.]		ifTrue: [ Transcript cr; show: 'Running test350LoadDataFromZipArchive '; cr ].	aFileName := '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	DailyStatMatrix loadDataFromZipArchiveNamed: aFileName.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/9/2013 10:59'!test360LoadDataFrom2007thru2009	"Read a zip file  in the investment source files directory"	| aFileName |		false ifFalse: [ Transcript cr; show: 'test360LoadDataFrom2007thru2009 has been turned off'. ^self.]		ifTrue: [ Transcript cr; show: 'Running test360LoadDataFrom2007thru2009 '; cr ].			"*** THIS IS FOR REAL -- CLEAR THE DATABASE ***"		DailyStatMatrix clearDatabase.	aFileName := '/Users/admin/Documents/InvestmentInformation/NYSE_2007.zip'.	DailyStatMatrix  loadDataFromZipArchiveNamed: aFileName.		aFileName := '/Users/admin/Documents/InvestmentInformation/NYSE_2008.zip'.	DailyStatMatrix  loadDataFromZipArchiveNamed: aFileName.			aFileName := '/Users/admin/Documents/InvestmentInformation/NYSE_2009.zip'.	DailyStatMatrix  loadDataFromZipArchiveNamed: aFileName.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/13/2013 14:15'!test370MapMissingPrices2007to2009	"Create a bitmap to visualize the problem data."	| priceMatrix width height pixelMatrix bitsPerPixel dateStart dateStop  increment tickerCounts dateCounts |	false ifTrue: [ Transcript cr; show: 'Running test370MapMissingPrices2007to2009'] 		ifFalse:   [ Transcript cr; show: 'test370MapMissingPrices2007to2009 is turned off'.			^self. ].			priceMatrix := DailyStatMatrix called: #close.	width := DailyStatMatrix tickers size.	height := DailyStatMatrix days size.	bitsPerPixel := 1. "0 = no data, 1 = got data."	pixelMatrix := Form extent: width@height depth: bitsPerPixel.		"Prepare to count"	tickerCounts := Dictionary new.	dateCounts := Dictionary new.	increment := [ :dict :key | 			| count |			count := dict at: key ifAbsent: [ 0 ].			count := count + 1.			dict at: key put: count.			].	"TODO: Think about adding a method to Dictionary or extending Dictionary"		dateStart := Date year: 2007 month: 01  day:  01.	dateStop := Date year: 2009 month: 12  day:  31.		priceMatrix forEachRowAndColumnFrom: dateStart until: dateStop 		do: [  :iTicker :iDay :value |			"The price matrix rows are tickers, columns are days			We will transpose for this visualization.			"			| x y bit ticker date |			x := iTicker .			y := iDay.			bit := ( value notNil ) asBit.			pixelMatrix pixelValueAt: x@y put: (bit).			"while we are at it, count by ticker and day."			( value isNil )				ifTrue: [	ticker := DailyStatMatrix rowHeads at: iTicker.						date := DailyStatMatrix columnHeads at: iDay.						increment value: tickerCounts value: ticker.		 				increment value: dateCounts value: date.						].			]. 			pixelMatrix writeBMPfileNamed: 'PriceMatrix2007to2009.bmp'.	"For some reason all tickers are missing on 23-July-2008"	self pareto: (tickerCounts select: [ :keyValue | 				| count |				count := keyValue value.				(count > 1)]).	self pareto: dateCounts.! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/13/2013 14:14'!test380ListProblemTickersFor2007to2009	"Create a bitmap to visualize the problem data."	| priceMatrix  dateStart dateStop troubleList |	false ifTrue: [ Transcript cr; show: 'Running test380ListProblemTickersFor2007to2009'] 		ifFalse:   [ Transcript cr; show: 'test380ListProblemTickersFor2007to2009 is turned off'.			^self. ].				priceMatrix := DailyStatMatrix called: #close.		dateStart := Date year: 2007 month: 01  day:  01.	dateStop := Date year: 2009 month: 12  day:  31.		troubleList := Set new.	priceMatrix forEachTickerAndDayFrom: dateStart until: dateStop 		do: [ :ticker :value |			( value isNil ) ifTrue: [ troubleList add: ticker ].   			]. . 		Transcript cr; show: 'test380ListProblemTickersFor2007to2009 trouble list: '.	Transcript cr; show: ( troubleList asSortedCollection  ).		! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 18:35'!test510ForEachTickerInDatabase	"Enumerate the tickers in the database."	| count  |				true ifFalse: [ Transcript cr; show: 'test510EnumerateTickersInDatabase has been turned off'. ^self.].			count := 0.	DailyStatMatrix  forEachTickerDo: [ :ticker  |  count := count + 1 ].		self assert: ( count > 2000 ).		Transcript cr; show: 'test510ForEachTickerInDatabase processed: ', ( count asString ),' tickers.';					cr.		! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 19:10'!test520ForEachDay	"Enumerate the tickers in the database."	| aTicker  count sumClose close matrix |				true ifFalse: [ Transcript cr; show: 'test520ForEachDay has been turned off'. ^self.].		count := 0.	sumClose := 0.0.	aTicker := 'DTE'.	matrix := DailyStatMatrix called: #close.	matrix forEachDayInHistoryOf: aTicker 								from: ( Date year: 2007 month: 01 day: 01 ) 								until:  ( Date year: 2009 month: 12 day: 31 )								do: [ :value |									 "Ignore nil and zero values"									 ( ( value notNil ) and: [ value > 0 ] )											ifTrue: [												sumClose := sumClose + value.												count := count + 1.												].												]. 		Transcript cr; show: 'test520ForEachDay processed: ', ( count asString ),' days.'.		Transcript cr; show: aTicker, ' average close: ', ( ( sumClose / count ) printShowingDecimalPlaces: 2  ).! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 17:58'!test530ForEachTickerAndDay	"Enumerate the tickers in the database."	|   countZero matrix |				true ifFalse: [ Transcript cr; show: 'test530ForEachTickerAndDay has been turned off'. ^self.].		countZero := 0.	matrix := DailyStatMatrix called: #close.	matrix forEachTickerAndDayFrom: ( Date year: 2007 month: 01 day: 01 ) 								until:  ( Date year: 2009 month: 12 day: 31 )								do: [ :ticker :value |									 "Ignore nil and zero values"									 ( ( value notNil ) and: [ value = 0 ] )											ifTrue: [												countZero := countZero + 1.												].												]. 		Transcript cr; show: 'test530ForEachTickerAndDay saw: ', ( countZero asString ),' zeroes.'.	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 17:58'!test540ForEachTickerAndDay	"Enumerate the tickers in the database."	|   countPositive matrix |				true ifFalse: [ Transcript cr; show: 'test540ForEachTickerAndDay has been turned off'. ^self.].		countPositive := 0.	matrix := DailyStatMatrix called: #close.	matrix forEachTickerAndDayFrom: ( Date year: 2007 month: 01 day: 01 ) 								until:  ( Date year: 2009 month: 12 day: 31 )								do: [ :ticker :value |									 "Ignore nil and zero values"									 ( ( value notNil ) and: [ value = 0 ] )											ifFalse: [												countPositive := countPositive + 1.												].												]. 		Transcript cr; show: 'test540ForEachTickerAndDay saw: ', ( countPositive asString ),' prices.'.	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 18:00'!test610ForSetNCumXCumX2	"Enumerate the tickers in the database."	|   matrix n cumX cumX2 priorRow filtered  count x x2 sumX sumX2 |				true ifFalse: [ Transcript cr; show: 'test610ForSetNCumXCumX2 has been turned off'. ^self.]		ifTrue: [ Transcript cr; show: 'Running test610ForSetNCumXCumX2' ].		matrix := DailyStatMatrix called: #close.	n := DailyStatMatrix called: #n.	cumX := DailyStatMatrix called: #cumX.	cumX2 := DailyStatMatrix called: #cumX2.		priorRow := 0.	filtered := 0.	"	count := 0.	sumX := 0.	sumX2 := 0.	"		matrix forEachRowAndColumnFrom: ( Date year: 2007 month: 01 day: 01 ) 								until:  ( Date year: 2009 month: 12 day: 31 )								do: [ :row :column :value |									|  |									"Each row is a ticker"									( row = priorRow ) ifFalse: [ count := 0. sumX := 0. sumX2 := 0. priorRow := row ].									 "Ignore nil and zero values"									 ( ( value isNil  ) or: [ value = 0 ] )											ifTrue: [ filtered := filtered + 1 ]											ifFalse: [												count := count + 1.												x := value.												sumX := sumX + x.												sumX2 := sumX2 + ( x*x).												n  matrix at: row at: column put: count.												cumX  matrix at: row at: column put: sumX.												cumX2 matrix at: row at: column put: sumX2.												].												]. 	Transcript cr; show: 'test610ForSetNCumXCumX2 set n cumX cumX2 '.	self assert: 2 equals: ( n forTicker: 'DTE' date: (Date year: 2007 month: 01 day: 2 )   ).	self assert: (48.41 * 2) equals: ( cumX forTicker: 'DTE' date: (Date year: 2007 month: 01 day: 2 )   ).	self assert: (48.41 * 48.41 * 2) equals: ( cumX2 forTicker: 'DTE' date: (Date year: 2007 month: 01 day: 2 )   ).	! !!DailyStatMatrixTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 2/8/2013 18:54'!test720GetSampleTickers	"Get a random sample of the tickers in the database."	| sampleTickers   |		self assert: ( DailyStatMatrix tickers size > 2000 ).	sampleTickers := DailyStatMatrix  sampleTickersOfSize:   100.	self assert: ( sampleTickers size = 100 ).	"Transcript cr; show: sampleTickers; cr."! !TestCase subclass: #EvolutionTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!EvolutionTests commentStamp: 'RichardAlexanderGreen 1/28/2013 07:37' prior: 0!A generation of strategies is created.Then each strategy is run.And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).The most fit strategies are then used to initialize the next generation.The most fit strategies are also mutated and added to the next generation.The process is iterated using a declining "energy" (amount of mutation). (simulated annealing)."1. Accumulate history of fitness. DONE2. Keep strategies with high average fitness in addition to current fitness. DO MORE3, Display current average fitness. DONE4. Change w+ w- so that they add to 100. DONE5. Develop some way to test sensitivity of parameters (%$ is suspect).6. Dither the start date so that lag is not training to a special event. DONE7. Log tickers that are removed with the stat day when data was found lacking. DONE8 Write a log file, not just Transcript for GA progress.9. Write a method that runs a set of strategies against the entire ticker base.10. Write a method to list tickers that were removed. DONE"!!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/10/2013 09:39'!test000TranscriptClear	Transcript clear.! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/5/2013 08:52'!test110CreateFirstGeneration	"A first generation of randomized stategies is created."	| evolution firstGeneration tab |	evolution := Evolution new.	firstGeneration := evolution createFirstGenerationSize: 100.	self assert: ( firstGeneration size = 100 ).	"List the generated strategies -- Eyeball to verify that strategies are randomized""		tab := String tab.	Transcript cr; show: ' lag', tab,' w+', tab, ' w-', tab, ' %G', tab, ' %L'.	firstGeneration 		do: [ :strategy |			| lag percentGain percentLoss weightPositive weightNegative   |			lag := strategy lag asString.			weightNegative := strategy weightNegative asString.			weightPositive := strategy weightPositive asString.			percentGain := strategy percentGain asString.			percentLoss := strategy percentLoss asString.			Transcript cr; show: lag, tab, weightPositive, tab, weightNegative, tab, percentGain, tab, percentLoss.						]."! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/5/2013 12:09'!test111StrategiesAreRunForGivenTimePeriod	"A first generation of randomized stategies is created."	| evolution firstGeneration tab |	evolution := Evolution new.	"Set the first and last day of the time period"	evolution		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 ).	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/5/2013 12:09'!test112StrategiesAreRunForGivenInitialCapital	"A first generation of randomized stategies is created."	| evolution firstGeneration tab |	evolution := Evolution new.	"Set the first and last day of the time period"	evolution		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 );		initialCapital: 100e3.	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/29/2013 22:13'!test113StrategiesAreRunForGivenSampleOfTickers	"A first generation of randomized stategies is created."	|  evolution sampleTickers |	evolution := Evolution new.	sampleTickers := DailyStatMatrix sampleTickersOfSize: 30.  	"Set the first and last day of the time period.	Identify the number of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 );		initialCapital: 100e3;		sampleTickers: sampleTickers.	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/29/2013 22:12'!test114StrategiesAreRunForInitialMutationPercent	"A first generation of randomized stategies is created."	|  evolution sampleTickers |	evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: 3.  	"Set the first and last day of the time period.	Identify the number of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90.  ! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/29/2013 22:12'!test115StrategiesAreRunForLimitedNumberOfIterations	"A first generation of randomized stategies is created."	|  evolution sampleTickers |	evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: 3.  	"Set the first and last day of the time period.	Identify the number of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 20.		evolution check.! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/29/2013 22:12'!test116StrategiesMayRunOneDayAWeek	"A first generation of randomized stategies is created."	|  evolution sampleTickers |	evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: 3.  	"Set the first and last day of the time period.	Identify  the number of tickers over which strategies will be run."		evolution		dayOfWeek: 4;		firstDay: (Date year: 2012 month: 01 day: 01 );		lastDay: (Date year: 2012 month: 01 day: 01 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 20.		evolution check.! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/20/2013 19:01'!test120RunFirstGeneration	"A first generation of randomized stategies is created.	The first generation is run.	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy portfolio   |	sizeSample := 3.	sizeGeneration := 1.	false 		ifFalse: [ Transcript cr; show: 'test120RunFirstGeneration is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test120RunFirstGeneration with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].			evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: sizeSample.  	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2008 month: 12 day: 31 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 3.  		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	self assert: ( firstGeneration size = sizeGeneration ).		"Run the firstGeneration"	experiencedGeneration := evolution runCurrentGeneration.	self assert: ( experiencedGeneration isKindOf: Set  ).	strategy := experiencedGeneration atRandom.	self assert: ( strategy isKindOf: Strategy ).    		"The run produces portfolios associated with each strategy"	portfolio := evolution portfolios at: strategy.	self assert: ( portfolio isKindOf: Portfolio    ).	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/29/2013 22:27'!test125RunFirstGenerationOnWednesdays	"A first generation of randomized stategies is created.	The first generation is run.	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy portfolio   |	sizeSample := 3.	sizeGeneration := 1.	true 		ifFalse: [ Transcript cr; show: 'test125RunFirstGenerationOnWednesdays is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test125RunFirstGenerationOnWednesdays with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].			evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: sizeSample.  	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution		dayOfWeek: 4;  		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2008 month: 12 day: 31 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 3.  		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	self assert: (sizeGeneration + 6) equals: ( firstGeneration size  ).		"Run the firstGeneration"	experiencedGeneration := evolution runCurrentGeneration.	self assert: ( experiencedGeneration isKindOf: Set  ).	strategy := experiencedGeneration atRandom.	self assert: ( strategy isKindOf: Strategy ).    		"The run produces portfolios associated with each strategy"	portfolio := evolution portfolios at: strategy.	self assert: ( portfolio isKindOf: Portfolio    ).		"Print the log"	evolution listLog .! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/20/2013 19:01'!test130EachStrategyHasAssociatedFitnessMetric	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of a portfolio at the end of the run ).	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  |	sizeSample := 3.	sizeGeneration := 1.	false 		ifFalse: [ Transcript cr; show: 'test130EachStrategyHasAssociatedFitnessMetric is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test130EachStrategyHasAssociatedFitnessMetric with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: sizeSample.  	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2008 month: 12 day: 31 );		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 3.  		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	self assert: ( firstGeneration size = sizeGeneration  ).		"Run the firstGeneration"	experiencedGeneration := evolution runCurrentGeneration.		"Look at a fitness metric to verify it exists"	strategy := ( experiencedGeneration atRandom ).	fitness := evolution fitnessOfStrategy: strategy.	self assert: ( fitness isKindOf: Number  ).		! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/20/2013 19:01'!test140TheMostFitStrategiesInitializeTheNextGeneration	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeSample sizeGeneration  evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration |	sizeSample := 3.	sizeGeneration := 2.	false 		ifFalse: [ Transcript cr; show: 'test140TheMostFitStrategiesInitializeTheNextGeneration is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test140TheMostFitStrategiesInitializeTheNextGeneration with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		evolution := Evolution new.	sampleTickers := DailyStatMatrix  sampleTickersOfSize: sizeSample.  	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2007 month: 12 day: 31 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 3.  	"Assure that all needed parameters are set."		evolution check.		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	self assert: ( firstGeneration size = sizeGeneration ).		"Run the firstGeneration"	experiencedGeneration := evolution runCurrentGeneration.		"Evolve the next generation"	nextGeneration := evolution nextGenerationFromTopPercent: 50.	self assert: ( nextGeneration size = sizeGeneration ).	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/28/2013 11:06'!test210SmallTrialRun	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |		sizeSample := 30.	sizeGeneration := 10.	true 		ifFalse: [ Transcript cr; show: 'test210SmallTrialRun is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test210SmallTrialRun with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		sampleTickers := DailyStatMatrix  sampleTickersOfSize: sizeSample.  	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: (Date year: 2008 month: 01 day: 01 );		lastDay: (Date year: 2008 month: 12 day: 31 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 10.  	"Assure that all needed parameters are set."		evolution check.		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	self assert: ( firstGeneration size = sizeGeneration ).		"Run the firstGeneration"	experiencedGeneration := evolution runCurrentGeneration.		"Evolve the next generation"	nextGeneration := evolution nextGenerationFromTopPercent: 50.	self assert: ( nextGeneration size = sizeGeneration ).		"Run a second iteration"	evolution currentGeneration: nextGeneration.	anotherGeneration := evolution runCurrentGeneration.	anotherGeneration := evolution nextGenerationFromTopPercent: 50.  		"Write log to file"	evolution listLogOnFile:   'test210SmallTrialRun', '-log.txt'.			! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/25/2013 11:20'!test220SmallEvolveForThreeCycles	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeGeneration sizeSample evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |		sizeGeneration := 10.	sizeSample := 30.	true 		ifFalse: [ Transcript cr; show: 'test220SmallEvolveForThreeCycles is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test220SmallEvolveForThreeCycles with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2009 month: 06 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 10.  	"Assure that all needed parameters are set."		evolution check.	firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 3 sampleSize:  sizeSample. 		! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/20/2013 19:00'!test225TwentyforTwentyOver30	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeGeneration sizeSample evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |		sizeGeneration := 20.	sizeSample := 30.	false 		ifFalse: [ Transcript cr; show: 'test225TwentyforTwentyOver30 is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test225TwentyforTwentyOver30 with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2009 month: 06 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 10.  	"Assure that all needed parameters are set."		evolution check.	firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 20 sampleSize:  sizeSample. 		! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/20/2013 22:53'!test226Twentyfor40Over60	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeGeneration sizeSample evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |		sizeGeneration := 20.	sizeSample := 60.	false 		ifFalse: [ Transcript cr; show: 'test226Twentyfor40Over60 is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test226Twentyfor40Over60 with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2009 month: 06 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;		iterationLimit: 40.  	"Assure that all needed parameters are set."		evolution check.	firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 40 sampleSize:  sizeSample. "The first successful run of this produced the following result:-----------------------------------------------------------------------------------Top fitness at iteration: 40 is: 1.02 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 32.9 %$ 3.5 %G 14.0 %L 16.1} transactions: 47Top fitness at iteration: 40 is: 1.02 for strategy: Strategy values {  lag: 74.6 w+ 0.3 w- 45.3 %$ 3.5 %G 14.0 %L 16.1} transactions: 49Top fitness at iteration: 40 is: 1.02 for strategy: Strategy values {  lag: 74.6 w+ 0.3 w- 33.5 %$ 3.5 %G 14.0 %L 16.1} transactions: 47Top fitness at iteration: 40 is: 1.02 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 54.6 %$ 3.5 %G 14.0 %L 16.1} transactions: 47For some samples in earlier generations fitness was as high as 1.05 . . .Top fitness at iteration: 37 is: 1.05 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 32.9 %$ 3.5 %G 14.0 %L 16.1} transactions: 80Top fitness at iteration: 37 is: 1.05 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 21.0 %$ 3.5 %G 14.0 %L 16.1} transactions: 82Top fitness at iteration: 37 is: 1.05 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 52.3 %$ 3.5 %G 14.0 %L 16.1} transactions: 80Top fitness at iteration: 37 is: 1.05 for strategy: Strategy values {  lag: 74.6 w+ 0.4 w- 59.0 %$ 3.5 %G 14.0 %L 16.1} transactions: 80However on a second run the best fitness was only 1.01 and the strategies settled at a quite different set of values:Top fitness at iteration: 40 is: 1.01 for strategy: Strategy values {  lag: 291.1 w+ 64.7 w- 7.1 %$ 2.9 %G 45.2 %L 17.3} transactions: 9Top fitness at iteration: 40 is: 1.01 for strategy: Strategy values {  lag: 291.1 w+ 100.0 w- 9.7 %$ 2.9 %G 45.2 %L 17.3} transactions: 9Top fitness at iteration: 40 is: 1.01 for strategy: Strategy values {  lag: 291.1 w+ 56.7 w- 7.1 %$ 2.9 %G 45.2 %L 17.3} transactions: 9Top fitness at iteration: 40 is: 1.01 for strategy: Strategy values {  lag: 291.1 w+ 100.0 w- 9.7 %$ 2.9 %G 45.2 %L 17.3} transactions: 9"		! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/25/2013 13:00'!test227Twentyfor20Over60	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeGeneration sizeSample evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |		sizeGeneration := 20.	sizeSample := 60.	true 		ifFalse: [ Transcript cr; show: 'test227Twentyfor20Over60 is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test227Twentyfor20Over60 with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].		"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: (Date year: 2007 month: 01 day: 01 );		lastDay: (Date year: 2009 month: 06 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 100e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 50;                "<<< Keep the top half."		iterationLimit: 40.  	"Assure that all needed parameters are set."		evolution check.	firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 20 sampleSize:  sizeSample. ! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/30/2013 14:43'!test230BiggerEvolveFor10Cycles	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |	sizeGeneration := 40.	sizeSample := 60.	true 		ifFalse: [ Transcript cr; cr; show: 'test230BigEvolveForTenCycles is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test230BigEvolveForTenCycles with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: ( Date year: 2007 month: 01 day: 01 );		lastDay: ( Date year: 2008 month: 07 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 200e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 25;		iterationLimit: 20.  	"Assure that all needed parameters are set."		evolution check.		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 10 sampleSize: sizeSample.  		evolution listLogOnFile: ( 'test230BiggerEvolveFor10Cycles','-log.txt' ).  	! !!EvolutionTests methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/30/2013 14:44'!test232BiggerEvolveFor20Cycles	"Each stategy has a fitness metric.	--	A generation of strategies is created.	Then each strategy is run.	And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).	The most fit strategies are then used to initialize the next generation.	"	| sizeSample sizeGeneration evolution sampleTickers firstGeneration experiencedGeneration strategy fitness  nextGeneration anotherGeneration |	sizeGeneration := 40.	sizeSample := 60.	true 		ifFalse: [ Transcript cr; cr; show: 'test232BiggerEvolveFor20Cycles is turned off.'; cr. ^self ]		ifTrue: [ "Ask first."					| answer |				Transcript 					cr; cr; 					show: 'Running test232BiggerEvolveFor20Cycles with sample of: ', sizeSample asString,							' and generations of size: ', sizeGeneration asString ;					cr.				answer := FillInTheBlankMorph request: 'Do you really want to run a test of this size?'												initialAnswer: 'Yes or No'.				( answer = 'Yes' ) ifTrue: [ "Proceed" ] ifFalse: [ ^self ].				].	"Set the first and last day of the time period.	Initialize the set of tickers over which strategies will be run."	evolution := Evolution new.	evolution		firstDay: ( Date year: 2007 month: 01 day: 01 );		lastDay: ( Date year: 2008 month: 07 day: 01 );		"Making first and last day the same causes runs to do nothing."		initialCapital: 200e3;		sampleTickers: sampleTickers;		initialMutationPercentage: 90;		passThruPercent: 25;		iterationLimit: 20.  	"Assure that all needed parameters are set."		evolution check.		firstGeneration := evolution createFirstGenerationSize: sizeGeneration.	evolution evolveCurrentGenerationForCycles: 20 sampleSize: sizeSample.  		evolution listLogOnFile: ( 'test232BiggerEvolveFor20Cycles','-log.txt' ).  	! !Object subclass: #Evolution	instanceVariableNames: 'firstGeneration currentGeneration portfolios lastDay firstDay initialCapital sampleTickers currentMutationPercent iterationLimit currentIteration passThruPercent myRandomizer log dayOfWeek'	classVariableNames: ''	poolDictionaries: ''	category: 'ragaa investing'!!Evolution commentStamp: 'RichardAlexanderGreen 1/5/2013 08:30' prior: 0!A generation of strategies is created.Then each strategy is run.And the strategy`s fitness metric is calculated. (The value of the portfolio at the end of the run ).The most fit strategies are then used to initialize the next generation.The most fit strategies are mutated and added to the next generation.The process is iterated using a declining "energy" (amount of mutation). (simulated annealing).!!Evolution methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/29/2013 22:32'!createFirstGenerationSize: anInteger	| strategyX  |	"Create the first generation of strategies"	currentGeneration := Set new.	"Salt it with some likely winners -- Magic numbers from prior runs"	strategyX := Strategy new.	strategyX 			dayOfWeek: ( self dayOfWeek );  			lag: 73;			weightPositive: 95;			percentCapital: 2;			percentGain: 50;			percentLoss: 4.	currentGeneration add: strategyX.	#( 29 68 86 104 161 )		do: [ :luckLag |  				currentGeneration add: ( (strategyX copy) lag: luckLag  ). 			].		"Generate the number suggested."	( 1 to: anInteger )		do: [ :x |			| strategy |			strategy := Strategy new.			strategy randomize.			strategy dayOfWeek: ( self dayOfWeek ).  			currentGeneration add: strategy.			( currentGeneration size >= anInteger ) ifTrue: [ ^currentGeneration ].			].	^ currentGeneration.! !!Evolution methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/25/2013 11:02'!evolveCurrentGenerationForCycles: nCycles sampleSize: sizeSample	"Cycle for the given generation the number of iterations.	"	| nStrategies nextGeneration |	nStrategies := currentGeneration  size.	self check.	Transcript cr; show: 'Evolving with a generation of size = ', (nStrategies asString), 						' for cycles = ', (nCycles asString),						' with varying samples of size = ', (sizeSample asString).	( 1 to: nCycles )		do: [ :cycle |			self sampleTickers: ( DailyStatMatrix sampleTickersOfSize: sizeSample ).  			Transcript cr; show: (TimeStamp now asString), 								' Starting cycle ', cycle asString , 								' generation size = ', ( currentGeneration size ) asString.			Transcript cr; show: self sampleTickers asString.  			self runCurrentGeneration.			nextGeneration := self nextGenerationFromTopPercent: ( self  passThruPercent ).  			self currentGeneration: nextGeneration.  			"Simulated Annealing"			self currentMutationPercent: ( currentMutationPercent * (0.9) ).   			Transcript cr; show: ' Current mutation percent: ', ( (self currentMutationPercent) printShowingDecimalPlaces: 2  ).			]		! !!Evolution methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/5/2013 12:32'!log: aString 	"Add the message string to the log.	Note:  This log is intended for test / debug, not audit.	TODO: Add a persistent audit-trail when that becomes relevant.	"	( self log ) add: aString.	! !!Evolution methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/25/2013 11:37'!nextGenerationFromTopPercent: topPercent 	"Evolve the next generation by selecting the given percent of the current generation."	| nextGeneration numberToSelect generationSortedByFitness generationSortedByAverageFitness groupToMutate |	self assert: ( topPercent isKindOf: Integer ).	numberToSelect := ( currentGeneration size ) * topPercent / 100.	self assert: ( numberToSelect > 0 ).	nextGeneration := Set new.	generationSortedByFitness := currentGeneration 									sorted: [ :strategyA :strategyB | 										| fitnessA fitnessB |										"Use my own fitness here.										Could be latest fitness or average fitness.										"										fitnessA := self fitnessOfStrategy: strategyA.										fitnessB := self fitnessOfStrategy: strategyB.										fitnessA > fitnessB.										].	"Select the top X%"	self assert: ( generationSortedByFitness size ) = ( currentGeneration size ).	generationSortedByFitness 		do: [ :strategy | 			( nextGeneration size < numberToSelect ) 				ifTrue: [ nextGeneration add: strategy.						( nextGeneration size <= 5 )							ifTrue: [ Transcript cr; show: 'Top fitness at iteration: ', currentIteration asString								                            , ' is: ',( (self fitnessOfStrategy: strategy) printShowingDecimalPlaces: 2 ).							Transcript show: ' for strategy: ', ( strategy shortReport ). 						 	Transcript show: ' transactions: ', (( self portfolios at: strategy ) transactions asString ). 							].					].  			].	"Also keep one or two of those with highest average fitness."	generationSortedByAverageFitness := currentGeneration 									sorted: [ :strategyA :strategyB | 										| fitnessA fitnessB |										fitnessA := strategyA averageFitness.										fitnessB := strategyB averageFitness.										fitnessA > fitnessB.										].	nextGeneration add: ( generationSortedByAverageFitness at: 1 ).		nextGeneration add: ( generationSortedByAverageFitness at: 2 ).		"Display the those two keepers"		Transcript cr; show: 'also keeping: ', (( generationSortedByAverageFitness at: 1 ) shortReport ).	Transcript cr; show: 'also keeping: ', (( generationSortedByAverageFitness at: 2 ) shortReport ).	"Mutate those randomly to fill out the next generation."	groupToMutate := nextGeneration copy.	[ nextGeneration size < ( currentGeneration size ) ]			whileTrue: [			| strategy mutatedStrategy |			"Pick a  strategy at random"			strategy := groupToMutate atRandom.			"Mutate it"			mutatedStrategy := strategy mutatedByPercent: ( self currentMutationPercent ).			"Add it into the nextGeneration"			nextGeneration add: mutatedStrategy.			].	^nextGeneration 	! !!Evolution methodsFor: 'updating' stamp: 'RichardAlexanderGreen 1/28/2013 08:12'!runCurrentGeneration	"Run the current generation of strategies."	"Associate a portfolio with each strategy"	self check.	portfolios := Dictionary new.	currentIteration := currentIteration + 1.	currentGeneration		do: [ :strategy |			| portfolio fitness |			portfolio := Portfolio new.			portfolio initialCapital: 100e3.			portfolio purchaseLimitPercent: ( strategy percentCapital ).			portfolio standardFee: 7.			portfolios at: strategy put: portfolio.			"Run the strategy on that portfolio"			strategy numberOfLives: ( 1 + ( strategy numberOfLives ) ).			fitness := strategy runForTickers: ( self sampleTickers ) from: ( self firstDayDithered  )  until: ( self lastDay ) inPortfolio: portfolio.			self log: ( 'runCurrentGeneration: ', (strategy shortReport)			             , ' fitness = ', ( fitness printShowingDecimalPlaces: 2 )			             , ' transactions: ', ( portfolio transactions asString )).			].	"Decrement the mutation percentage"	currentMutationPercent := currentMutationPercent * ( 100 - ( 100 / iterationLimit ) ) / 100.	^ currentGeneration.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/10/2013 13:57'!check	"Check that all necessary attributes are not nil"	#( #firstDay #lastDay #initialCapital #iterationLimit #currentIteration #currentMutationPercent #passThruPercent  )		do: [ :attribute |			| value |			value := self perform: attribute.			value ifNil: [ Error signal: 'Evolution is missing value for: ', ( attribute asString) ].			 ]! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/7/2013 19:29'!currentGeneration: aSet 	currentGeneration := aSet! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:53'!currentIteration	^ currentIteration! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/7/2013 19:31'!currentIteration: anInteger	currentIteration := anInteger! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 11:22'!currentMutationPercent	"What is the current allowed mutation percentage?"	^ currentMutationPercent! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/20/2013 22:05'!currentMutationPercent: aFloat 	currentMutationPercent := aFloat! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/29/2013 22:19'!dayOfWeek	 ^ dayOfWeek! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/29/2013 22:11'!dayOfWeek: aDayCode	"Operate (buy and sell) only on the given day of the week.	Sunday == 1" 	dayOfWeek := aDayCode.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:36'!firstDay	^ firstDay! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 09:54'!firstDay: aDate 	"Set the first day for the time period over which strategies are run"	firstDay := aDate.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 14:28'!firstDayDithered	"Return the first day dithered by some random number of weeks.	The purpose of this is to avoid having strategies set the lag due to some special event in the sample period.	"	| ditherDay random |	random := ( self random ).		ditherDay := ( firstDay addDays: ( 7 * ( random nextInt: 7 )  )    ).	^ ditherDay! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 10:24'!fitnessOfStrategy: aStrategy 	| fitness |	fitness := aStrategy fitness.	^fitness.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:53'!initialCapital	^ initialCapital! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 09:57'!initialCapital: anlInteger 	"Strategies are run with portfolios having the given initial capital"	initialCapital := anlInteger.	! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 11:47'!initialMutationPercentage: percent 	"This is the initial percentage.	The allowed percentage of mutation will be reduced from generation to generation.	(This is a form of simulated annealing)	"	self assert: ( percent isKindOf: Number ).  	currentMutationPercent := percent.	! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:53'!iterationLimit	^ iterationLimit! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:25'!iterationLimit: aSmallInteger 	"The number of iterations (generations) is limited by this upper bound"	iterationLimit := aSmallInteger. 	currentIteration := 0.	! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 09:50'!lastDay	"What is the last day of period on which strategies are run. See also #firstDay"	^ lastDay.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 09:55'!lastDay: aDate	"Set the last day over which the strategies will be run" 	lastDay := aDate! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/8/2013 09:38'!passThruPercent	"Percent of current generation that will be used to generate the next generation.	The top X% will be kept and mutated to create the next generation.	"	^passThruPercent.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/8/2013 09:39'!passThruPercent: anInteger	"Percent of current generation that will be used to generate the next generation.	The top X% will be kept and mutated to create the next generation.	"	passThruPercent := anInteger.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 09:27'!portfolios	" portfolios associates a portfolio with each strategy "	^ portfolios ifNil: [ portfolios := Dictionary new ].	! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/25/2013 12:21'!random	myRandomizer 		ifNil: [ myRandomizer := Random new.			myRandomizer initialize.			].	^myRandomizer.! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 12:36'!sampleTickers	^ sampleTickers! !!Evolution methodsFor: 'accessing' stamp: 'RichardAlexanderGreen 1/5/2013 10:27'!sampleTickers: aSet 	"Initialize the set of tickers over which strategies will be run."	sampleTickers := aSet.	! !!Evolution methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/28/2013 08:15'!listLog	"List the contents of the log on Transcript"	Transcript cr; show: 'Evolution Log: '.	( self log )		do: [ :entry |			Transcript cr; show: entry.			].! !!Evolution methodsFor: 'as yet unclassified' stamp: 'RichardAlexanderGreen 1/28/2013 11:00'!listLogOnFile: aFilename	"List the contents of the log on disk file."	| file |	file := StandardFileStream forceNewFileNamed: aFilename.   		( self log )		do: [ :entry |			file nextPutAll: ( entry, String cr ).  			].	file close.! !!Evolution methodsFor: 'debugging' stamp: 'RichardAlexanderGreen 1/28/2013 10:56'!log	^ log ifNil: [ log := OrderedCollection new ].! !